"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/signup/page",{

/***/ "(app-pages-browser)/./src/utils/auth.ts":
/*!***************************!*\
  !*** ./src/utils/auth.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adminSupabase: function() { return /* binding */ adminSupabase; },\n/* harmony export */   checkSession: function() { return /* binding */ checkSession; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   endSession: function() { return /* binding */ endSession; },\n/* harmony export */   generateToken: function() { return /* binding */ generateToken; },\n/* harmony export */   getSession: function() { return /* binding */ getSession; },\n/* harmony export */   saveSession: function() { return /* binding */ saveSession; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   validateSession: function() { return /* binding */ validateSession; },\n/* harmony export */   verifyAdmin: function() { return /* binding */ verifyAdmin; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _fingerprint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fingerprint */ \"(app-pages-browser)/./src/utils/fingerprint.ts\");\n\n\n\n// Create a Supabase client with the service role key for admin operations\nconst serviceRoleKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjeHh2bmljemx5enl1bXVpb2hjIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczMjM1MDMwMywiZXhwIjoyMDQ3OTI2MzAzfQ.50LNYYbfszw6IzHma3S6SIL53ZGFfVpj0Ty1x3ycj0o\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjeHh2bmljemx5enl1bXVpb2hjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzIzNTAzMDMsImV4cCI6MjA0NzkyNjMwM30.AM5S6xAISMEH41V7pLsJSznd-b2hiene5ZGOClgZh-4\");\n// Create a separate client with service role for session management\nconst adminSupabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", serviceRoleKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n});\n// Function to create a new session\nasync function createSession(userId, deviceFingerprint) {\n    try {\n        console.log(\"Creating new session for user:\", userId);\n        const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n        // First, deactivate any existing sessions using admin client\n        const { error: deactivateError } = await adminSupabase.from(\"sessions\").update({\n            is_active: false\n        }).eq(\"user_id\", userId).eq(\"is_active\", true);\n        if (deactivateError) {\n            console.error(\"Error deactivating existing sessions:\", deactivateError);\n        }\n        // Create new session using admin client\n        const { error: createError } = await adminSupabase.from(\"sessions\").insert([\n            {\n                user_id: userId,\n                session_id: sessionId,\n                device_fingerprint: deviceFingerprint,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                last_active: new Date().toISOString()\n            }\n        ]);\n        if (createError) {\n            console.error(\"Error creating session:\", createError);\n            throw new Error(\"Failed to create session\");\n        }\n        console.log(\"Successfully created session with ID:\", sessionId);\n        return sessionId;\n    } catch (error) {\n        console.error(\"Session creation error:\", error);\n        throw error;\n    }\n}\n// Function to check if user has an active session\nasync function checkActiveSession(userId) {\n    const { data: sessions, error } = await supabase.from(\"sessions\").select(\"*\").eq(\"user_id\", userId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"Error checking active session:\", error);\n        return false;\n    }\n    return !!sessions;\n}\n// Function to validate session\nasync function validateSession(sessionId, userId) {\n    try {\n        console.log(\"Validating session:\", {\n            sessionId,\n            userId\n        });\n        // Get current device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        // Use admin client for session validation\n        const { data: session, error } = await adminSupabase.from(\"sessions\").select(\"*\").eq(\"session_id\", sessionId).eq(\"user_id\", userId).eq(\"is_active\", true).single();\n        if (error) {\n            console.error(\"Session validation error:\", error);\n            return false;\n        }\n        if (!session) {\n            console.log(\"No active session found\");\n            return false;\n        }\n        // Verify device fingerprint matches\n        if (session.device_fingerprint !== deviceFingerprint) {\n            console.log(\"Device fingerprint mismatch\");\n            // Deactivate this session since it's being accessed from a different browser\n            await adminSupabase.from(\"sessions\").update({\n                is_active: false\n            }).eq(\"session_id\", sessionId);\n            return false;\n        }\n        console.log(\"Found active session:\", session);\n        // Update last_active timestamp using admin client\n        const { error: updateError } = await adminSupabase.from(\"sessions\").update({\n            last_active: new Date().toISOString()\n        }).eq(\"session_id\", sessionId);\n        if (updateError) {\n            console.error(\"Error updating last_active:\", updateError);\n        // Don't fail validation just because we couldn't update timestamp\n        }\n        return true;\n    } catch (error) {\n        console.error(\"Unexpected error in validateSession:\", error);\n        return false;\n    }\n}\n// Function to end session\nasync function endSession(sessionId) {\n    await adminSupabase.from(\"sessions\").update({\n        is_active: false\n    }).eq(\"session_id\", sessionId);\n}\nasync function signIn(username, password) {\n    try {\n        console.log(\"Starting sign in process for username:\", username);\n        // Get current device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Device fingerprint:\", deviceFingerprint);\n        // Check if this is an admin login attempt\n        if (username === \"Bharani\") {\n            if (password === \"HackerBharani\") {\n                const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n                const adminSession = {\n                    username: username,\n                    isLoggedIn: true,\n                    isAdmin: true,\n                    deviceFingerprint,\n                    sessionId,\n                    userId: \"admin\" // Special case for admin\n                };\n                saveSession(adminSession);\n                return adminSession;\n            }\n            throw new Error(\"Invalid username or password\");\n        }\n        // Normal user authentication\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", username).single();\n        if (userError || !userData) {\n            console.error(\"User lookup error:\", userError);\n            throw new Error(\"Invalid username or password\");\n        }\n        // Check for existing active sessions\n        const { data: existingSessions, error: sessionError } = await adminSupabase.from(\"sessions\").select(\"*\").eq(\"user_id\", userData.id).eq(\"is_active\", true);\n        if (sessionError) {\n            console.error(\"Error checking existing sessions:\", sessionError);\n        } else if (existingSessions && existingSessions.length > 0) {\n            const currentSession = existingSessions[0];\n            if (currentSession.device_fingerprint !== deviceFingerprint) {\n                throw new Error(\"You are already logged in from another browser. Please sign out there first.\");\n            }\n        }\n        // Create new session\n        let sessionId;\n        try {\n            sessionId = await createSession(userData.id, deviceFingerprint);\n            console.log(\"Created new session:\", sessionId);\n        } catch (error) {\n            console.error(\"Failed to create session:\", error);\n            throw new Error(\"Failed to create session. Please try again.\");\n        }\n        const userSession = {\n            username: userData.username,\n            userId: userData.id,\n            isLoggedIn: true,\n            sessionId,\n            token: userData.token,\n            deviceFingerprint,\n            tokenExpiry: userData.token_expiry\n        };\n        saveSession(userSession);\n        return userSession;\n    } catch (error) {\n        console.error(\"Sign in error:\", error);\n        throw error;\n    }\n}\nasync function signUp(username, password, token) {\n    try {\n        console.log(\"Starting sign up process for username:\", username);\n        // Get device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Generated device fingerprint:\", deviceFingerprint);\n        // Check if username already exists\n        const { data: existingUser, error: userCheckError } = await supabase.from(\"users\").select(\"username\").eq(\"username\", username).single();\n        if (userCheckError) {\n            console.error(\"Error checking existing user:\", userCheckError);\n        }\n        if (existingUser) {\n            throw new Error(\"Username already exists\");\n        }\n        // Verify token exists and get expiry date\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", token).single();\n        if (tokenError) {\n            console.error(\"Token verification error:\", tokenError);\n            throw new Error(\"Invalid token\");\n        }\n        if (!tokenData) {\n            throw new Error(\"Invalid token\");\n        }\n        // Check if token is already used\n        if (tokenData.is_used) {\n            throw new Error(\"Token has already been used\");\n        }\n        // Create new user with device fingerprint\n        const newUserData = {\n            username,\n            password,\n            token,\n            device_fingerprint: deviceFingerprint,\n            created_at: new Date().toISOString(),\n            token_expiry: tokenData.expiry_date\n        };\n        console.log(\"Attempting to create user with data:\", {\n            ...newUserData,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        const { data: newUser, error: createError } = await supabase.from(\"users\").insert([\n            newUserData\n        ]).select().single();\n        if (createError) {\n            console.error(\"Detailed error creating user:\", {\n                message: createError.message,\n                details: createError.details,\n                hint: createError.hint,\n                code: createError.code\n            });\n            throw new Error(\"Failed to create user account: \".concat(createError.message));\n        }\n        // Mark token as used\n        const { error: updateError } = await supabase.from(\"tokens\").update({\n            is_used: true,\n            used_by: username\n        }).eq(\"token\", token);\n        if (updateError) {\n            console.error(\"Error updating token status:\", updateError);\n        // Consider rolling back user creation here\n        }\n        console.log(\"Successfully created user:\", {\n            ...newUser,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        return {\n            user: newUser,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Sign up error:\", error);\n        throw error;\n    }\n}\nasync function signOut() {\n    try {\n        const session = getSession();\n        if ((session === null || session === void 0 ? void 0 : session.sessionId) && (session === null || session === void 0 ? void 0 : session.userId)) {\n            // Use admin client for session termination\n            const { error } = await adminSupabase.from(\"sessions\").update({\n                is_active: false\n            }).eq(\"session_id\", session.sessionId).eq(\"user_id\", session.userId);\n            if (error) {\n                console.error(\"Error ending session:\", error);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during sign out:\", error);\n    } finally{\n        clearSession();\n    }\n}\nfunction saveSession(user) {\n    try {\n        localStorage.setItem(\"session\", JSON.stringify(user));\n    } catch (error) {\n        console.error(\"Error saving session:\", error);\n    }\n}\nfunction getSession() {\n    try {\n        const session = localStorage.getItem(\"session\");\n        if (!session) return null;\n        return JSON.parse(session);\n    } catch (error) {\n        console.error(\"Error reading session:\", error);\n        return null;\n    }\n}\nfunction clearSession() {\n    localStorage.removeItem(\"session\");\n}\nasync function checkSession() {\n    const session = getSession();\n    if (!session || !session.isLoggedIn) return null;\n    // Check if this is an admin session\n    if (session.isAdmin) {\n        if (session.username === \"Bharani\") {\n            return session;\n        }\n        clearSession();\n        return null;\n    }\n    try {\n        console.log(\"Checking session for user:\", session.username);\n        // Get user data\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", session.username).single();\n        if (userError) {\n            console.error(\"User lookup error:\", userError);\n            // Don't clear session immediately on network errors\n            if (userError.code !== \"PGRST116\") {\n                return session; // Keep session on temporary errors\n            }\n            clearSession();\n            throw new Error(\"Failed to verify user access\");\n        }\n        if (!userData) {\n            clearSession();\n            throw new Error(\"User not found or access revoked\");\n        }\n        // Get token data\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", userData.token).single();\n        if (tokenError) {\n            console.error(\"Token lookup error:\", tokenError);\n            // Don't clear session immediately on network errors\n            if (tokenError.code !== \"PGRST116\") {\n                return session; // Keep session on temporary errors\n            }\n        }\n        if (!tokenData) {\n            clearSession();\n            throw new Error(\"Invalid token. Please contact admin.\");\n        }\n        // Check if token is expired\n        const expiryDate = new Date(tokenData.expiry_date);\n        if (expiryDate < new Date()) {\n            clearSession();\n            throw new Error(\"Your access token has expired. Please contact admin for renewal.\");\n        }\n        // Check if token is still active\n        if (!tokenData.is_used) {\n            clearSession();\n            throw new Error(\"Your token has been deactivated. Please contact admin to reactivate.\");\n        }\n        // Validate session if we have the required data\n        if (session.sessionId && session.userId) {\n            const isValidSession = await validateSession(session.sessionId, session.userId);\n            if (!isValidSession) {\n                console.warn(\"Session validation failed, but keeping session active\");\n                // Instead of clearing immediately, we'll keep the session\n                return session;\n            }\n        }\n        // Update the session with latest data\n        const updatedSession = {\n            ...session,\n            username: userData.username,\n            userId: userData.id,\n            isLoggedIn: true,\n            isAdmin: false,\n            token: userData.token,\n            deviceFingerprint: session.deviceFingerprint\n        };\n        // Save the updated session\n        saveSession(updatedSession);\n        return updatedSession;\n    } catch (error) {\n        console.error(\"Session check error:\", error);\n        // Only clear session for specific authentication errors\n        if (error.message.includes(\"revoked\") || error.message.includes(\"expired\") || error.message.includes(\"deactivated\")) {\n            clearSession();\n        }\n        throw error;\n    }\n}\nfunction generateToken() {\n    let duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1h\";\n    // Generate a unique token using UUID\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n}\nasync function verifyAdmin() {\n    const adminSession = localStorage.getItem(\"adminSession\");\n    if (!adminSession) return false;\n    try {\n        const session = JSON.parse(adminSession);\n        return session.username === \"Bharani\" && session.isLoggedIn === true;\n    } catch (error) {\n        console.error(\"Error verifying admin session:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkE7UUFFdEMsd0RBQXdEO1FBQ3hELElBQUlBLE1BQU1zRCxPQUFPLENBQUNxQixRQUFRLENBQUMsY0FDdkIzRSxNQUFNc0QsT0FBTyxDQUFDcUIsUUFBUSxDQUFDLGNBQ3ZCM0UsTUFBTXNELE9BQU8sQ0FBQ3FCLFFBQVEsQ0FBQyxnQkFBZ0I7WUFDekNiO1FBQ0Y7UUFFQSxNQUFNOUQ7SUFDUjtBQUNGO0FBRU8sU0FBUzRFO1FBQWNDLFdBQUFBLGlFQUFtQjtJQUMvQyxxQ0FBcUM7SUFDckMsT0FBT2hHLGdEQUFNQTtBQUNmO0FBRU8sZUFBZWlHO0lBQ3BCLE1BQU1oRCxlQUFlaUMsYUFBYUksT0FBTyxDQUFDO0lBQzFDLElBQUksQ0FBQ3JDLGNBQWMsT0FBTztJQUUxQixJQUFJO1FBQ0YsTUFBTVIsVUFBVTJDLEtBQUtHLEtBQUssQ0FBQ3RDO1FBQzNCLE9BQU9SLFFBQVFJLFFBQVEsS0FBSzFDLFNBQXNDLElBQUlzQyxRQUFRUyxVQUFVLEtBQUs7SUFDL0YsRUFBRSxPQUFPL0IsT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMsa0NBQWtDQTtRQUNoRCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYXV0aC50cz9mZDI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IGdldERldmljZUZpbmdlcnByaW50IH0gZnJvbSAnLi9maW5nZXJwcmludCc7XG5cbi8vIENyZWF0ZSBhIFN1cGFiYXNlIGNsaWVudCB3aXRoIHRoZSBzZXJ2aWNlIHJvbGUga2V5IGZvciBhZG1pbiBvcGVyYXRpb25zXG5jb25zdCBzZXJ2aWNlUm9sZUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIVxuKTtcblxuLy8gQ3JlYXRlIGEgc2VwYXJhdGUgY2xpZW50IHdpdGggc2VydmljZSByb2xlIGZvciBzZXNzaW9uIG1hbmFnZW1lbnRcbmV4cG9ydCBjb25zdCBhZG1pblN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhLFxuICBzZXJ2aWNlUm9sZUtleSEsXG4gIHtcbiAgICBhdXRoOiB7XG4gICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgIHBlcnNpc3RTZXNzaW9uOiBmYWxzZVxuICAgIH1cbiAgfVxuKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyU2Vzc2lvbiB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIGlzTG9nZ2VkSW46IGJvb2xlYW47XG4gIHRva2VuRXhwaXJ5Pzogc3RyaW5nO1xuICB0b2tlbj86IHN0cmluZyB8IG51bGw7XG4gIGlzQWRtaW4/OiBib29sZWFuO1xuICBkZXZpY2VGaW5nZXJwcmludD86IHN0cmluZztcbiAgdXNlcklkPzogc3RyaW5nO1xuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBzZXNzaW9uXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTZXNzaW9uKHVzZXJJZDogc3RyaW5nLCBkZXZpY2VGaW5nZXJwcmludDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IHNlc3Npb24gZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSB1dWlkdjQoKTtcblxuICAgIC8vIEZpcnN0LCBkZWFjdGl2YXRlIGFueSBleGlzdGluZyBzZXNzaW9ucyB1c2luZyBhZG1pbiBjbGllbnRcbiAgICBjb25zdCB7IGVycm9yOiBkZWFjdGl2YXRlRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgICAudXBkYXRlKHsgaXNfYWN0aXZlOiBmYWxzZSB9KVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKTtcblxuICAgIGlmIChkZWFjdGl2YXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlYWN0aXZhdGluZyBleGlzdGluZyBzZXNzaW9uczonLCBkZWFjdGl2YXRlRXJyb3IpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgc2Vzc2lvbiB1c2luZyBhZG1pbiBjbGllbnRcbiAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgIC5pbnNlcnQoW3tcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgIGRldmljZV9maW5nZXJwcmludDogZGV2aWNlRmluZ2VycHJpbnQsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBsYXN0X2FjdGl2ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XSk7XG5cbiAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNlc3Npb246JywgY3JlYXRlRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24nKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgc2Vzc2lvbiB3aXRoIElEOicsIHNlc3Npb25JZCk7XG4gICAgcmV0dXJuIHNlc3Npb25JZDtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gY3JlYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIHVzZXIgaGFzIGFuIGFjdGl2ZSBzZXNzaW9uXG5hc3luYyBmdW5jdGlvbiBjaGVja0FjdGl2ZVNlc3Npb24odXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgeyBkYXRhOiBzZXNzaW9ucywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhY3RpdmUgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhc2Vzc2lvbnM7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIHZhbGlkYXRlIHNlc3Npb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZhbGlkYXRpbmcgc2Vzc2lvbjonLCB7IHNlc3Npb25JZCwgdXNlcklkIH0pO1xuICAgIFxuICAgIC8vIEdldCBjdXJyZW50IGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IGRldmljZUZpbmdlcnByaW50ID0gYXdhaXQgZ2V0RGV2aWNlRmluZ2VycHJpbnQoKTtcbiAgICBcbiAgICAvLyBVc2UgYWRtaW4gY2xpZW50IGZvciBzZXNzaW9uIHZhbGlkYXRpb25cbiAgICBjb25zdCB7IGRhdGE6IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWQpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gYWN0aXZlIHNlc3Npb24gZm91bmQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgZGV2aWNlIGZpbmdlcnByaW50IG1hdGNoZXNcbiAgICBpZiAoc2Vzc2lvbi5kZXZpY2VfZmluZ2VycHJpbnQgIT09IGRldmljZUZpbmdlcnByaW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnRGV2aWNlIGZpbmdlcnByaW50IG1pc21hdGNoJyk7XG4gICAgICAvLyBEZWFjdGl2YXRlIHRoaXMgc2Vzc2lvbiBzaW5jZSBpdCdzIGJlaW5nIGFjY2Vzc2VkIGZyb20gYSBkaWZmZXJlbnQgYnJvd3NlclxuICAgICAgYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgICAudXBkYXRlKHsgaXNfYWN0aXZlOiBmYWxzZSB9KVxuICAgICAgICAuZXEoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdGb3VuZCBhY3RpdmUgc2Vzc2lvbjonLCBzZXNzaW9uKTtcblxuICAgIC8vIFVwZGF0ZSBsYXN0X2FjdGl2ZSB0aW1lc3RhbXAgdXNpbmcgYWRtaW4gY2xpZW50XG4gICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgICAudXBkYXRlKHsgbGFzdF9hY3RpdmU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuICAgICAgLmVxKCdzZXNzaW9uX2lkJywgc2Vzc2lvbklkKTtcblxuICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbGFzdF9hY3RpdmU6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgZmFpbCB2YWxpZGF0aW9uIGp1c3QgYmVjYXVzZSB3ZSBjb3VsZG4ndCB1cGRhdGUgdGltZXN0YW1wXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiB2YWxpZGF0ZVNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBlbmQgc2Vzc2lvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuZFNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAuZXEoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJTZXNzaW9uPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNpZ24gaW4gcHJvY2VzcyBmb3IgdXNlcm5hbWU6JywgdXNlcm5hbWUpO1xuXG4gICAgLy8gR2V0IGN1cnJlbnQgZGV2aWNlIGZpbmdlcnByaW50XG4gICAgY29uc3QgZGV2aWNlRmluZ2VycHJpbnQgPSBhd2FpdCBnZXREZXZpY2VGaW5nZXJwcmludCgpO1xuICAgIGNvbnNvbGUubG9nKCdEZXZpY2UgZmluZ2VycHJpbnQ6JywgZGV2aWNlRmluZ2VycHJpbnQpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhZG1pbiBsb2dpbiBhdHRlbXB0XG4gICAgaWYgKHVzZXJuYW1lID09PSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BRE1JTl9VU0VSTkFNRSkge1xuICAgICAgaWYgKHBhc3N3b3JkID09PSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BRE1JTl9QQVNTV09SRCkge1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSB1dWlkdjQoKTtcbiAgICAgICAgY29uc3QgYWRtaW5TZXNzaW9uOiBVc2VyU2Vzc2lvbiA9IHtcbiAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgaXNMb2dnZWRJbjogdHJ1ZSxcbiAgICAgICAgICBpc0FkbWluOiB0cnVlLFxuICAgICAgICAgIGRldmljZUZpbmdlcnByaW50LFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICB1c2VySWQ6ICdhZG1pbicgLy8gU3BlY2lhbCBjYXNlIGZvciBhZG1pblxuICAgICAgICB9O1xuICAgICAgICBzYXZlU2Vzc2lvbihhZG1pblNlc3Npb24pO1xuICAgICAgICByZXR1cm4gYWRtaW5TZXNzaW9uO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsIHVzZXIgYXV0aGVudGljYXRpb25cbiAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd1c2VybmFtZScsIHVzZXJuYW1lKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlckRhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXIgbG9va3VwIGVycm9yOicsIHVzZXJFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUgb3IgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgZXhpc3RpbmcgYWN0aXZlIHNlc3Npb25zXG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1Nlc3Npb25zLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyRGF0YS5pZClcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSk7XG5cbiAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBleGlzdGluZyBzZXNzaW9uczonLCBzZXNzaW9uRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdTZXNzaW9ucyAmJiBleGlzdGluZ1Nlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gZXhpc3RpbmdTZXNzaW9uc1swXTtcbiAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5kZXZpY2VfZmluZ2VycHJpbnQgIT09IGRldmljZUZpbmdlcnByaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBhbHJlYWR5IGxvZ2dlZCBpbiBmcm9tIGFub3RoZXIgYnJvd3Nlci4gUGxlYXNlIHNpZ24gb3V0IHRoZXJlIGZpcnN0LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgc2Vzc2lvblxuICAgIGxldCBzZXNzaW9uSWQ6IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgc2Vzc2lvbklkID0gYXdhaXQgY3JlYXRlU2Vzc2lvbih1c2VyRGF0YS5pZCwgZGV2aWNlRmluZ2VycHJpbnQpO1xuICAgICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgbmV3IHNlc3Npb246Jywgc2Vzc2lvbklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJTZXNzaW9uOiBVc2VyU2Vzc2lvbiA9IHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcbiAgICAgIHVzZXJJZDogdXNlckRhdGEuaWQsXG4gICAgICBpc0xvZ2dlZEluOiB0cnVlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdG9rZW46IHVzZXJEYXRhLnRva2VuLFxuICAgICAgZGV2aWNlRmluZ2VycHJpbnQsXG4gICAgICB0b2tlbkV4cGlyeTogdXNlckRhdGEudG9rZW5fZXhwaXJ5XG4gICAgfTtcblxuICAgIHNhdmVTZXNzaW9uKHVzZXJTZXNzaW9uKTtcbiAgICByZXR1cm4gdXNlclNlc3Npb247XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ24gaW4gZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduVXAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgdG9rZW46IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNpZ24gdXAgcHJvY2VzcyBmb3IgdXNlcm5hbWU6JywgdXNlcm5hbWUpO1xuXG4gICAgLy8gR2V0IGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IGRldmljZUZpbmdlcnByaW50ID0gYXdhaXQgZ2V0RGV2aWNlRmluZ2VycHJpbnQoKTtcbiAgICBjb25zb2xlLmxvZygnR2VuZXJhdGVkIGRldmljZSBmaW5nZXJwcmludDonLCBkZXZpY2VGaW5nZXJwcmludCk7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VybmFtZSBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VyLCBlcnJvcjogdXNlckNoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgndXNlcm5hbWUnKVxuICAgICAgLmVxKCd1c2VybmFtZScsIHVzZXJuYW1lKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHVzZXJDaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBleGlzdGluZyB1c2VyOicsIHVzZXJDaGVja0Vycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RpbmdVc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXJuYW1lIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRva2VuIGV4aXN0cyBhbmQgZ2V0IGV4cGlyeSBkYXRlXG4gICAgY29uc3QgeyBkYXRhOiB0b2tlbkRhdGEsIGVycm9yOiB0b2tlbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Rva2VucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9rZW4nLCB0b2tlbilcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh0b2tlbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiB2ZXJpZmljYXRpb24gZXJyb3I6JywgdG9rZW5FcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRva2VuRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgYWxyZWFkeSB1c2VkXG4gICAgaWYgKHRva2VuRGF0YS5pc191c2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCcpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgdXNlciB3aXRoIGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IG5ld1VzZXJEYXRhID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHRva2VuLFxuICAgICAgZGV2aWNlX2ZpbmdlcnByaW50OiBkZXZpY2VGaW5nZXJwcmludCxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHRva2VuX2V4cGlyeTogdG9rZW5EYXRhLmV4cGlyeV9kYXRlXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSB1c2VyIHdpdGggZGF0YTonLCB7IFxuICAgICAgLi4ubmV3VXNlckRhdGEsXG4gICAgICBwYXNzd29yZDogJ1tSRURBQ1RFRF0nLFxuICAgICAgdG9rZW46ICdbUkVEQUNURURdJ1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBkYXRhOiBuZXdVc2VyLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLmluc2VydChbbmV3VXNlckRhdGFdKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RldGFpbGVkIGVycm9yIGNyZWF0aW5nIHVzZXI6Jywge1xuICAgICAgICBtZXNzYWdlOiBjcmVhdGVFcnJvci5tZXNzYWdlLFxuICAgICAgICBkZXRhaWxzOiBjcmVhdGVFcnJvci5kZXRhaWxzLFxuICAgICAgICBoaW50OiBjcmVhdGVFcnJvci5oaW50LFxuICAgICAgICBjb2RlOiBjcmVhdGVFcnJvci5jb2RlXG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB1c2VyIGFjY291bnQ6ICR7Y3JlYXRlRXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRva2VuIGFzIHVzZWRcbiAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd0b2tlbnMnKVxuICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICBpc191c2VkOiB0cnVlLFxuICAgICAgICB1c2VkX2J5OiB1c2VybmFtZVxuICAgICAgfSlcbiAgICAgIC5lcSgndG9rZW4nLCB0b2tlbik7XG5cbiAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRva2VuIHN0YXR1czonLCB1cGRhdGVFcnJvcik7XG4gICAgICAvLyBDb25zaWRlciByb2xsaW5nIGJhY2sgdXNlciBjcmVhdGlvbiBoZXJlXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIHVzZXI6JywgeyBcbiAgICAgIC4uLm5ld1VzZXIsXG4gICAgICBwYXNzd29yZDogJ1tSRURBQ1RFRF0nLFxuICAgICAgdG9rZW46ICdbUkVEQUNURURdJ1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IG5ld1VzZXIsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ24gdXAgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KCkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBnZXRTZXNzaW9uKCk7XG4gICAgaWYgKHNlc3Npb24/LnNlc3Npb25JZCAmJiBzZXNzaW9uPy51c2VySWQpIHtcbiAgICAgIC8vIFVzZSBhZG1pbiBjbGllbnQgZm9yIHNlc3Npb24gdGVybWluYXRpb25cbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAgICAgLmVxKCdzZXNzaW9uX2lkJywgc2Vzc2lvbi5zZXNzaW9uSWQpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHNlc3Npb24udXNlcklkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVuZGluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHNpZ24gb3V0OicsIGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhclNlc3Npb24oKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVNlc3Npb24odXNlcjogVXNlclNlc3Npb24pIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2Vzc2lvbicsIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlc3Npb24oKTogVXNlclNlc3Npb24gfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Nlc3Npb24nKTtcbiAgICBpZiAoIXNlc3Npb24pIHJldHVybiBudWxsO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHNlc3Npb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU2Vzc2lvbigpIHtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Nlc3Npb24nKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrU2Vzc2lvbigpIHtcbiAgY29uc3Qgc2Vzc2lvbiA9IGdldFNlc3Npb24oKTtcbiAgaWYgKCFzZXNzaW9uIHx8ICFzZXNzaW9uLmlzTG9nZ2VkSW4pIHJldHVybiBudWxsO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gYWRtaW4gc2Vzc2lvblxuICBpZiAoc2Vzc2lvbi5pc0FkbWluKSB7XG4gICAgaWYgKHNlc3Npb24udXNlcm5hbWUgPT09IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX1VTRVJOQU1FKSB7XG4gICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9XG4gICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBzZXNzaW9uIGZvciB1c2VyOicsIHNlc3Npb24udXNlcm5hbWUpO1xuXG4gICAgLy8gR2V0IHVzZXIgZGF0YVxuICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJuYW1lJywgc2Vzc2lvbi51c2VybmFtZSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXIgbG9va3VwIGVycm9yOicsIHVzZXJFcnJvcik7XG4gICAgICAvLyBEb24ndCBjbGVhciBzZXNzaW9uIGltbWVkaWF0ZWx5IG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICBpZiAodXNlckVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb247IC8vIEtlZXAgc2Vzc2lvbiBvbiB0ZW1wb3JhcnkgZXJyb3JzXG4gICAgICB9XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHZlcmlmeSB1c2VyIGFjY2VzcycpO1xuICAgIH1cblxuICAgIGlmICghdXNlckRhdGEpIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCBvciBhY2Nlc3MgcmV2b2tlZCcpO1xuICAgIH1cblxuICAgIC8vIEdldCB0b2tlbiBkYXRhXG4gICAgY29uc3QgeyBkYXRhOiB0b2tlbkRhdGEsIGVycm9yOiB0b2tlbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Rva2VucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9rZW4nLCB1c2VyRGF0YS50b2tlbilcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh0b2tlbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBsb29rdXAgZXJyb3I6JywgdG9rZW5FcnJvcik7XG4gICAgICAvLyBEb24ndCBjbGVhciBzZXNzaW9uIGltbWVkaWF0ZWx5IG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICBpZiAodG9rZW5FcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uOyAvLyBLZWVwIHNlc3Npb24gb24gdGVtcG9yYXJ5IGVycm9yc1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdG9rZW5EYXRhKSB7XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b2tlbi4gUGxlYXNlIGNvbnRhY3QgYWRtaW4uJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgZXhwaXJlZFxuICAgIGNvbnN0IGV4cGlyeURhdGUgPSBuZXcgRGF0ZSh0b2tlbkRhdGEuZXhwaXJ5X2RhdGUpO1xuICAgIGlmIChleHBpcnlEYXRlIDwgbmV3IERhdGUoKSkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgYWNjZXNzIHRva2VuIGhhcyBleHBpcmVkLiBQbGVhc2UgY29udGFjdCBhZG1pbiBmb3IgcmVuZXdhbC4nKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBzdGlsbCBhY3RpdmVcbiAgICBpZiAoIXRva2VuRGF0YS5pc191c2VkKSB7XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciB0b2tlbiBoYXMgYmVlbiBkZWFjdGl2YXRlZC4gUGxlYXNlIGNvbnRhY3QgYWRtaW4gdG8gcmVhY3RpdmF0ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBzZXNzaW9uIGlmIHdlIGhhdmUgdGhlIHJlcXVpcmVkIGRhdGFcbiAgICBpZiAoc2Vzc2lvbi5zZXNzaW9uSWQgJiYgc2Vzc2lvbi51c2VySWQpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKHNlc3Npb24uc2Vzc2lvbklkLCBzZXNzaW9uLnVzZXJJZCk7XG4gICAgICBpZiAoIWlzVmFsaWRTZXNzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2Vzc2lvbiB2YWxpZGF0aW9uIGZhaWxlZCwgYnV0IGtlZXBpbmcgc2Vzc2lvbiBhY3RpdmUnKTtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBjbGVhcmluZyBpbW1lZGlhdGVseSwgd2UnbGwga2VlcCB0aGUgc2Vzc2lvblxuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHNlc3Npb24gd2l0aCBsYXRlc3QgZGF0YVxuICAgIGNvbnN0IHVwZGF0ZWRTZXNzaW9uID0ge1xuICAgICAgLi4uc2Vzc2lvbixcbiAgICAgIHVzZXJuYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcbiAgICAgIHVzZXJJZDogdXNlckRhdGEuaWQsXG4gICAgICBpc0xvZ2dlZEluOiB0cnVlLFxuICAgICAgaXNBZG1pbjogZmFsc2UsXG4gICAgICB0b2tlbjogdXNlckRhdGEudG9rZW4sXG4gICAgICBkZXZpY2VGaW5nZXJwcmludDogc2Vzc2lvbi5kZXZpY2VGaW5nZXJwcmludFxuICAgIH07XG5cbiAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIHNlc3Npb25cbiAgICBzYXZlU2Vzc2lvbih1cGRhdGVkU2Vzc2lvbik7XG5cbiAgICByZXR1cm4gdXBkYXRlZFNlc3Npb247XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gY2hlY2sgZXJyb3I6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIE9ubHkgY2xlYXIgc2Vzc2lvbiBmb3Igc3BlY2lmaWMgYXV0aGVudGljYXRpb24gZXJyb3JzXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3Jldm9rZWQnKSB8fCBcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZXhwaXJlZCcpIHx8IFxuICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkZWFjdGl2YXRlZCcpKSB7XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVG9rZW4oZHVyYXRpb246IHN0cmluZyA9ICcxaCcpOiBzdHJpbmcge1xuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSB0b2tlbiB1c2luZyBVVUlEXG4gIHJldHVybiB1dWlkdjQoKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUFkbWluKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBhZG1pblNlc3Npb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5TZXNzaW9uJyk7XG4gIGlmICghYWRtaW5TZXNzaW9uKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gSlNPTi5wYXJzZShhZG1pblNlc3Npb24pO1xuICAgIHJldHVybiBzZXNzaW9uLnVzZXJuYW1lID09PSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BRE1JTl9VU0VSTkFNRSAmJiBzZXNzaW9uLmlzTG9nZ2VkSW4gPT09IHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGFkbWluIHNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInY0IiwidXVpZHY0IiwiZ2V0RGV2aWNlRmluZ2VycHJpbnQiLCJzZXJ2aWNlUm9sZUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwic3VwYWJhc2UiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImFkbWluU3VwYWJhc2UiLCJhdXRoIiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiY3JlYXRlU2Vzc2lvbiIsInVzZXJJZCIsImRldmljZUZpbmdlcnByaW50IiwiY29uc29sZSIsImxvZyIsInNlc3Npb25JZCIsImVycm9yIiwiZGVhY3RpdmF0ZUVycm9yIiwiZnJvbSIsInVwZGF0ZSIsImlzX2FjdGl2ZSIsImVxIiwiY3JlYXRlRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwic2Vzc2lvbl9pZCIsImRldmljZV9maW5nZXJwcmludCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsYXN0X2FjdGl2ZSIsIkVycm9yIiwiY2hlY2tBY3RpdmVTZXNzaW9uIiwiZGF0YSIsInNlc3Npb25zIiwic2VsZWN0Iiwic2luZ2xlIiwidmFsaWRhdGVTZXNzaW9uIiwic2Vzc2lvbiIsInVwZGF0ZUVycm9yIiwiZW5kU2Vzc2lvbiIsInNpZ25JbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJORVhUX1BVQkxJQ19BRE1JTl9VU0VSTkFNRSIsIk5FWFRfUFVCTElDX0FETUlOX1BBU1NXT1JEIiwiYWRtaW5TZXNzaW9uIiwiaXNMb2dnZWRJbiIsImlzQWRtaW4iLCJzYXZlU2Vzc2lvbiIsInVzZXJEYXRhIiwidXNlckVycm9yIiwiZXhpc3RpbmdTZXNzaW9ucyIsInNlc3Npb25FcnJvciIsImlkIiwibGVuZ3RoIiwiY3VycmVudFNlc3Npb24iLCJ1c2VyU2Vzc2lvbiIsInRva2VuIiwidG9rZW5FeHBpcnkiLCJ0b2tlbl9leHBpcnkiLCJzaWduVXAiLCJleGlzdGluZ1VzZXIiLCJ1c2VyQ2hlY2tFcnJvciIsInRva2VuRGF0YSIsInRva2VuRXJyb3IiLCJpc191c2VkIiwibmV3VXNlckRhdGEiLCJleHBpcnlfZGF0ZSIsIm5ld1VzZXIiLCJtZXNzYWdlIiwiZGV0YWlscyIsImhpbnQiLCJjb2RlIiwidXNlZF9ieSIsInVzZXIiLCJzaWduT3V0IiwiZ2V0U2Vzc2lvbiIsImNsZWFyU2Vzc2lvbiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SXRlbSIsInBhcnNlIiwicmVtb3ZlSXRlbSIsImNoZWNrU2Vzc2lvbiIsImV4cGlyeURhdGUiLCJpc1ZhbGlkU2Vzc2lvbiIsIndhcm4iLCJ1cGRhdGVkU2Vzc2lvbiIsImluY2x1ZGVzIiwiZ2VuZXJhdGVUb2tlbiIsImR1cmF0aW9uIiwidmVyaWZ5QWRtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/auth.ts\n"));

/***/ })

});