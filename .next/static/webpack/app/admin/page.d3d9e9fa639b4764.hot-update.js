"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/utils/auth.ts":
/*!***************************!*\
  !*** ./src/utils/auth.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adminSupabase: function() { return /* binding */ adminSupabase; },\n/* harmony export */   checkSession: function() { return /* binding */ checkSession; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   endSession: function() { return /* binding */ endSession; },\n/* harmony export */   generateToken: function() { return /* binding */ generateToken; },\n/* harmony export */   getSession: function() { return /* binding */ getSession; },\n/* harmony export */   saveSession: function() { return /* binding */ saveSession; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   validateSession: function() { return /* binding */ validateSession; },\n/* harmony export */   verifyAdmin: function() { return /* binding */ verifyAdmin; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _fingerprint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fingerprint */ \"(app-pages-browser)/./src/utils/fingerprint.ts\");\n\n\n\n// Create a Supabase client with the service role key for admin operations\nconst serviceRoleKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjeHh2bmljemx5enl1bXVpb2hjIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczMjM1MDMwMywiZXhwIjoyMDQ3OTI2MzAzfQ.50LNYYbfszw6IzHma3S6SIL53ZGFfVpj0Ty1x3ycj0o\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjeHh2bmljemx5enl1bXVpb2hjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzIzNTAzMDMsImV4cCI6MjA0NzkyNjMwM30.AM5S6xAISMEH41V7pLsJSznd-b2hiene5ZGOClgZh-4\");\n// Create a separate client with service role for session management\nconst adminSupabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", serviceRoleKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n});\n// Function to create a new session\nasync function createSession(userId, deviceFingerprint) {\n    try {\n        console.log(\"Creating new session for user:\", userId);\n        const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n        // First, deactivate any existing sessions using admin client\n        const { error: deactivateError } = await adminSupabase.from(\"sessions\").update({\n            is_active: false\n        }).eq(\"user_id\", userId).eq(\"is_active\", true);\n        if (deactivateError) {\n            console.error(\"Error deactivating existing sessions:\", deactivateError);\n        }\n        // Create new session using admin client\n        const { error: createError } = await adminSupabase.from(\"sessions\").insert([\n            {\n                user_id: userId,\n                session_id: sessionId,\n                device_fingerprint: deviceFingerprint,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                last_active: new Date().toISOString()\n            }\n        ]);\n        if (createError) {\n            console.error(\"Error creating session:\", createError);\n            throw new Error(\"Failed to create session\");\n        }\n        console.log(\"Successfully created session with ID:\", sessionId);\n        return sessionId;\n    } catch (error) {\n        console.error(\"Session creation error:\", error);\n        throw error;\n    }\n}\n// Function to check if user has an active session\nasync function checkActiveSession(userId) {\n    const { data: sessions, error } = await supabase.from(\"sessions\").select(\"*\").eq(\"user_id\", userId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"Error checking active session:\", error);\n        return false;\n    }\n    return !!sessions;\n}\n// Function to validate session\nasync function validateSession(sessionId, userId) {\n    try {\n        console.log(\"Validating session:\", {\n            sessionId,\n            userId\n        });\n        // Use admin client for session validation\n        const { data: session, error } = await adminSupabase.from(\"sessions\").select(\"*\").eq(\"session_id\", sessionId).eq(\"user_id\", userId).eq(\"is_active\", true).single();\n        if (error) {\n            console.error(\"Session validation error:\", error);\n            return false;\n        }\n        if (!session) {\n            console.log(\"No active session found\");\n            return false;\n        }\n        console.log(\"Found active session:\", session);\n        // Update last_active timestamp using admin client\n        const { error: updateError } = await adminSupabase.from(\"sessions\").update({\n            last_active: new Date().toISOString()\n        }).eq(\"session_id\", sessionId).eq(\"user_id\", userId);\n        if (updateError) {\n            console.error(\"Error updating last_active:\", updateError);\n        // Don't fail validation just because we couldn't update timestamp\n        }\n        return true;\n    } catch (error) {\n        console.error(\"Unexpected error in validateSession:\", error);\n        return false;\n    }\n}\n// Function to end session\nasync function endSession(sessionId) {\n    await adminSupabase.from(\"sessions\").update({\n        is_active: false\n    }).eq(\"session_id\", sessionId);\n}\nasync function signIn(username, password) {\n    try {\n        console.log(\"Starting sign in process for username:\", username);\n        // Get current device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Device fingerprint:\", deviceFingerprint);\n        // Check if this is an admin login attempt\n        if (username === \"Bharani\") {\n            if (password === \"HackerBharani\") {\n                const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n                const adminSession = {\n                    username: username,\n                    isLoggedIn: true,\n                    isAdmin: true,\n                    deviceFingerprint,\n                    sessionId,\n                    userId: \"admin\" // Special case for admin\n                };\n                saveSession(adminSession);\n                return adminSession;\n            }\n            throw new Error(\"Invalid username or password\");\n        }\n        // Normal user authentication\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", username).single();\n        if (userError || !userData) {\n            console.error(\"User lookup error:\", userError);\n            throw new Error(\"Invalid username or password\");\n        }\n        // Check for existing active sessions\n        const { data: existingSessions, error: sessionError } = await adminSupabase.from(\"sessions\").select(\"*\").eq(\"user_id\", userData.id).eq(\"is_active\", true);\n        if (sessionError) {\n            console.error(\"Error checking existing sessions:\", sessionError);\n        } else if (existingSessions && existingSessions.length > 0) {\n            const currentSession = existingSessions[0];\n            if (currentSession.device_fingerprint !== deviceFingerprint) {\n                throw new Error(\"You are already logged in from another browser. Please sign out there first.\");\n            }\n        }\n        // Create new session\n        let sessionId;\n        try {\n            sessionId = await createSession(userData.id, deviceFingerprint);\n            console.log(\"Created new session:\", sessionId);\n        } catch (error) {\n            console.error(\"Failed to create session:\", error);\n            throw new Error(\"Failed to create session. Please try again.\");\n        }\n        const userSession = {\n            username: userData.username,\n            userId: userData.id,\n            isLoggedIn: true,\n            sessionId,\n            token: userData.token,\n            deviceFingerprint,\n            tokenExpiry: userData.token_expiry\n        };\n        saveSession(userSession);\n        return userSession;\n    } catch (error) {\n        console.error(\"Sign in error:\", error);\n        throw error;\n    }\n}\nasync function signUp(username, password, token) {\n    try {\n        console.log(\"Starting sign up process for username:\", username);\n        // Get device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Generated device fingerprint:\", deviceFingerprint);\n        // Check if username already exists\n        const { data: existingUser, error: userCheckError } = await supabase.from(\"users\").select(\"username\").eq(\"username\", username).single();\n        if (userCheckError) {\n            console.error(\"Error checking existing user:\", userCheckError);\n        }\n        if (existingUser) {\n            throw new Error(\"Username already exists\");\n        }\n        // Verify token exists and get expiry date\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", token).single();\n        if (tokenError) {\n            console.error(\"Token verification error:\", tokenError);\n            throw new Error(\"Invalid token\");\n        }\n        if (!tokenData) {\n            throw new Error(\"Invalid token\");\n        }\n        // Check if token is already used\n        if (tokenData.is_used) {\n            throw new Error(\"Token has already been used\");\n        }\n        // Create new user with device fingerprint\n        const newUserData = {\n            username,\n            password,\n            token,\n            device_fingerprint: deviceFingerprint,\n            created_at: new Date().toISOString(),\n            token_expiry: tokenData.expiry_date\n        };\n        console.log(\"Attempting to create user with data:\", {\n            ...newUserData,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        const { data: newUser, error: createError } = await supabase.from(\"users\").insert([\n            newUserData\n        ]).select().single();\n        if (createError) {\n            console.error(\"Detailed error creating user:\", {\n                message: createError.message,\n                details: createError.details,\n                hint: createError.hint,\n                code: createError.code\n            });\n            throw new Error(\"Failed to create user account: \".concat(createError.message));\n        }\n        // Mark token as used\n        const { error: updateError } = await supabase.from(\"tokens\").update({\n            is_used: true,\n            used_by: username\n        }).eq(\"token\", token);\n        if (updateError) {\n            console.error(\"Error updating token status:\", updateError);\n        // Consider rolling back user creation here\n        }\n        console.log(\"Successfully created user:\", {\n            ...newUser,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        return {\n            user: newUser,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Sign up error:\", error);\n        throw error;\n    }\n}\nasync function signOut() {\n    try {\n        const session = getSession();\n        if ((session === null || session === void 0 ? void 0 : session.sessionId) && (session === null || session === void 0 ? void 0 : session.userId)) {\n            // Use admin client for session termination\n            const { error } = await adminSupabase.from(\"sessions\").update({\n                is_active: false\n            }).eq(\"session_id\", session.sessionId).eq(\"user_id\", session.userId);\n            if (error) {\n                console.error(\"Error ending session:\", error);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during sign out:\", error);\n    } finally{\n        clearSession();\n    }\n}\nfunction saveSession(user) {\n    try {\n        localStorage.setItem(\"session\", JSON.stringify(user));\n    } catch (error) {\n        console.error(\"Error saving session:\", error);\n    }\n}\nfunction getSession() {\n    try {\n        const session = localStorage.getItem(\"session\");\n        if (!session) return null;\n        return JSON.parse(session);\n    } catch (error) {\n        console.error(\"Error reading session:\", error);\n        return null;\n    }\n}\nfunction clearSession() {\n    localStorage.removeItem(\"session\");\n}\nasync function checkSession() {\n    const session = getSession();\n    if (!session || !session.isLoggedIn) return null;\n    // Check if this is an admin session\n    if (session.isAdmin) {\n        if (session.username === \"Bharani\") {\n            return session;\n        }\n        clearSession();\n        return null;\n    }\n    try {\n        console.log(\"Checking session for user:\", session.username);\n        // Get user data\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", session.username).single();\n        if (userError) {\n            console.error(\"User lookup error:\", userError);\n            // Don't clear session immediately on network errors\n            if (userError.code !== \"PGRST116\") {\n                return session; // Keep session on temporary errors\n            }\n            clearSession();\n            throw new Error(\"Failed to verify user access\");\n        }\n        if (!userData) {\n            clearSession();\n            throw new Error(\"User not found or access revoked\");\n        }\n        // Get token data\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", userData.token).single();\n        if (tokenError) {\n            console.error(\"Token lookup error:\", tokenError);\n            // Don't clear session immediately on network errors\n            if (tokenError.code !== \"PGRST116\") {\n                return session; // Keep session on temporary errors\n            }\n        }\n        if (!tokenData) {\n            clearSession();\n            throw new Error(\"Invalid token. Please contact admin.\");\n        }\n        // Check if token is expired\n        const expiryDate = new Date(tokenData.expiry_date);\n        if (expiryDate < new Date()) {\n            clearSession();\n            throw new Error(\"Your access token has expired. Please contact admin for renewal.\");\n        }\n        // Check if token is still active\n        if (!tokenData.is_used) {\n            clearSession();\n            throw new Error(\"Your token has been deactivated. Please contact admin to reactivate.\");\n        }\n        // Validate session if we have the required data\n        if (session.sessionId && session.userId) {\n            const isValidSession = await validateSession(session.sessionId, session.userId);\n            if (!isValidSession) {\n                console.warn(\"Session validation failed, but keeping session active\");\n                // Instead of clearing immediately, we'll keep the session\n                return session;\n            }\n        }\n        // Update the session with latest data\n        const updatedSession = {\n            ...session,\n            username: userData.username,\n            userId: userData.id,\n            isLoggedIn: true,\n            isAdmin: false,\n            token: userData.token,\n            deviceFingerprint: session.deviceFingerprint\n        };\n        // Save the updated session\n        saveSession(updatedSession);\n        return updatedSession;\n    } catch (error) {\n        console.error(\"Session check error:\", error);\n        // Only clear session for specific authentication errors\n        if (error.message.includes(\"revoked\") || error.message.includes(\"expired\") || error.message.includes(\"deactivated\")) {\n            clearSession();\n        }\n        throw error;\n    }\n}\nfunction generateToken() {\n    let duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1h\";\n    // Generate a unique token using UUID\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n}\nasync function verifyAdmin() {\n    const adminSession = localStorage.getItem(\"adminSession\");\n    if (!adminSession) return false;\n    try {\n        const session = JSON.parse(adminSession);\n        return session.username === \"Bharani\" && session.isLoggedIn === true;\n    } catch (error) {\n        console.error(\"Error verifying admin session:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUNBQXFDO0lBQ3JDLE9BQU9oRyxnREFBTUE7QUFDZjtBQUVPLGVBQWVpRztJQUNwQixNQUFNaEQsZUFBZWlDLGFBQWFJLE9BQU8sQ0FBQztJQUMxQyxJQUFJLENBQUNyQyxjQUFjLE9BQU87SUFFMUIsSUFBSTtRQUNGLE1BQU1SLFVBQVUyQyxLQUFLRyxLQUFLLENBQUN0QztRQUMzQixPQUFPUixRQUFRSSxRQUFRLEtBQUsxQyxTQUFzQyxJQUFJc0MsUUFBUVMsVUFBVSxLQUFLO0lBQy9GLEVBQUUsT0FBTy9CLE9BQU87UUFDZEgsUUFBUUcsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2F1dGgudHM/ZmQyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBnZXREZXZpY2VGaW5nZXJwcmludCB9IGZyb20gJy4vZmluZ2VycHJpbnQnO1xuXG4vLyBDcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQgd2l0aCB0aGUgc2VydmljZSByb2xlIGtleSBmb3IgYWRtaW4gb3BlcmF0aW9uc1xuY29uc3Qgc2VydmljZVJvbGVLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhLFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcbik7XG5cbi8vIENyZWF0ZSBhIHNlcGFyYXRlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSBmb3Igc2Vzc2lvbiBtYW5hZ2VtZW50XG5leHBvcnQgY29uc3QgYWRtaW5TdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgc2VydmljZVJvbGVLZXkhLFxuICB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2VcbiAgICB9XG4gIH1cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclNlc3Npb24ge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBpc0xvZ2dlZEluOiBib29sZWFuO1xuICB0b2tlbkV4cGlyeT86IHN0cmluZztcbiAgdG9rZW4/OiBzdHJpbmcgfCBudWxsO1xuICBpc0FkbWluPzogYm9vbGVhbjtcbiAgZGV2aWNlRmluZ2VycHJpbnQ/OiBzdHJpbmc7XG4gIHVzZXJJZD86IHN0cmluZztcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgc2Vzc2lvblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbih1c2VySWQ6IHN0cmluZywgZGV2aWNlRmluZ2VycHJpbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG5ldyBzZXNzaW9uIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgY29uc3Qgc2Vzc2lvbklkID0gdXVpZHY0KCk7XG5cbiAgICAvLyBGaXJzdCwgZGVhY3RpdmF0ZSBhbnkgZXhpc3Rpbmcgc2Vzc2lvbnMgdXNpbmcgYWRtaW4gY2xpZW50XG4gICAgY29uc3QgeyBlcnJvcjogZGVhY3RpdmF0ZUVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWFjdGl2YXRpbmcgZXhpc3Rpbmcgc2Vzc2lvbnM6JywgZGVhY3RpdmF0ZUVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHNlc3Npb24gdXNpbmcgYWRtaW4gY2xpZW50XG4gICAgY29uc3QgeyBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgICAuaW5zZXJ0KFt7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICBkZXZpY2VfZmluZ2VycHJpbnQ6IGRldmljZUZpbmdlcnByaW50LFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdF9hY3RpdmU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfV0pO1xuXG4gICAgaWYgKGNyZWF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzZXNzaW9uOicsIGNyZWF0ZUVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIHNlc3Npb24gd2l0aCBJRDonLCBzZXNzaW9uSWQpO1xuICAgIHJldHVybiBzZXNzaW9uSWQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGNyZWF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjaGVjayBpZiB1c2VyIGhhcyBhbiBhY3RpdmUgc2Vzc2lvblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBY3RpdmVTZXNzaW9uKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbnMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYWN0aXZlIHNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIXNlc3Npb25zO1xufVxuXG4vLyBGdW5jdGlvbiB0byB2YWxpZGF0ZSBzZXNzaW9uXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVTZXNzaW9uKHNlc3Npb25JZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW5nIHNlc3Npb246JywgeyBzZXNzaW9uSWQsIHVzZXJJZCB9KTtcbiAgICBcbiAgICAvLyBVc2UgYWRtaW4gY2xpZW50IGZvciBzZXNzaW9uIHZhbGlkYXRpb25cbiAgICBjb25zdCB7IGRhdGE6IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWQpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gYWN0aXZlIHNlc3Npb24gZm91bmQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRm91bmQgYWN0aXZlIHNlc3Npb246Jywgc2Vzc2lvbik7XG5cbiAgICAvLyBVcGRhdGUgbGFzdF9hY3RpdmUgdGltZXN0YW1wIHVzaW5nIGFkbWluIGNsaWVudFxuICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgICAgLnVwZGF0ZSh7IGxhc3RfYWN0aXZlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAgIC5lcSgnc2Vzc2lvbl9pZCcsIHNlc3Npb25JZClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG5cbiAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGxhc3RfYWN0aXZlOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgIC8vIERvbid0IGZhaWwgdmFsaWRhdGlvbiBqdXN0IGJlY2F1c2Ugd2UgY291bGRuJ3QgdXBkYXRlIHRpbWVzdGFtcFxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gdmFsaWRhdGVTZXNzaW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gZW5kIHNlc3Npb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmRTZXNzaW9uKHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgIC51cGRhdGUoeyBpc19hY3RpdmU6IGZhbHNlIH0pXG4gICAgLmVxKCdzZXNzaW9uX2lkJywgc2Vzc2lvbklkKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25Jbih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyU2Vzc2lvbj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBzaWduIGluIHByb2Nlc3MgZm9yIHVzZXJuYW1lOicsIHVzZXJuYW1lKTtcblxuICAgIC8vIEdldCBjdXJyZW50IGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IGRldmljZUZpbmdlcnByaW50ID0gYXdhaXQgZ2V0RGV2aWNlRmluZ2VycHJpbnQoKTtcbiAgICBjb25zb2xlLmxvZygnRGV2aWNlIGZpbmdlcnByaW50OicsIGRldmljZUZpbmdlcnByaW50KTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gYWRtaW4gbG9naW4gYXR0ZW1wdFxuICAgIGlmICh1c2VybmFtZSA9PT0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fVVNFUk5BTUUpIHtcbiAgICAgIGlmIChwYXNzd29yZCA9PT0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fUEFTU1dPUkQpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gdXVpZHY0KCk7XG4gICAgICAgIGNvbnN0IGFkbWluU2Vzc2lvbjogVXNlclNlc3Npb24gPSB7XG4gICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgICAgIGlzTG9nZ2VkSW46IHRydWUsXG4gICAgICAgICAgaXNBZG1pbjogdHJ1ZSxcbiAgICAgICAgICBkZXZpY2VGaW5nZXJwcmludCxcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgdXNlcklkOiAnYWRtaW4nIC8vIFNwZWNpYWwgY2FzZSBmb3IgYWRtaW5cbiAgICAgICAgfTtcbiAgICAgICAgc2F2ZVNlc3Npb24oYWRtaW5TZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGFkbWluU2Vzc2lvbjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbCB1c2VyIGF1dGhlbnRpY2F0aW9uXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcm5hbWUnLCB1c2VybmFtZSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh1c2VyRXJyb3IgfHwgIXVzZXJEYXRhKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVc2VyIGxvb2t1cCBlcnJvcjonLCB1c2VyRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGFjdGl2ZSBzZXNzaW9uc1xuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdTZXNzaW9ucywgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlckRhdGEuaWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpO1xuXG4gICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZXhpc3Rpbmcgc2Vzc2lvbnM6Jywgc2Vzc2lvbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU2Vzc2lvbnMgJiYgZXhpc3RpbmdTZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGV4aXN0aW5nU2Vzc2lvbnNbMF07XG4gICAgICBpZiAoY3VycmVudFNlc3Npb24uZGV2aWNlX2ZpbmdlcnByaW50ICE9PSBkZXZpY2VGaW5nZXJwcmludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgYWxyZWFkeSBsb2dnZWQgaW4gZnJvbSBhbm90aGVyIGJyb3dzZXIuIFBsZWFzZSBzaWduIG91dCB0aGVyZSBmaXJzdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHNlc3Npb25cbiAgICBsZXQgc2Vzc2lvbklkOiBzdHJpbmc7XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25JZCA9IGF3YWl0IGNyZWF0ZVNlc3Npb24odXNlckRhdGEuaWQsIGRldmljZUZpbmdlcnByaW50KTtcbiAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIG5ldyBzZXNzaW9uOicsIHNlc3Npb25JZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc2Vzc2lvbi4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2Vzc2lvbjogVXNlclNlc3Npb24gPSB7XG4gICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUsXG4gICAgICB1c2VySWQ6IHVzZXJEYXRhLmlkLFxuICAgICAgaXNMb2dnZWRJbjogdHJ1ZSxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIHRva2VuOiB1c2VyRGF0YS50b2tlbixcbiAgICAgIGRldmljZUZpbmdlcnByaW50LFxuICAgICAgdG9rZW5FeHBpcnk6IHVzZXJEYXRhLnRva2VuX2V4cGlyeVxuICAgIH07XG5cbiAgICBzYXZlU2Vzc2lvbih1c2VyU2Vzc2lvbik7XG4gICAgcmV0dXJuIHVzZXJTZXNzaW9uO1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTaWduIGluIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblVwKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBzaWduIHVwIHByb2Nlc3MgZm9yIHVzZXJuYW1lOicsIHVzZXJuYW1lKTtcblxuICAgIC8vIEdldCBkZXZpY2UgZmluZ2VycHJpbnRcbiAgICBjb25zdCBkZXZpY2VGaW5nZXJwcmludCA9IGF3YWl0IGdldERldmljZUZpbmdlcnByaW50KCk7XG4gICAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCBkZXZpY2UgZmluZ2VycHJpbnQ6JywgZGV2aWNlRmluZ2VycHJpbnQpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdXNlcm5hbWUgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nVXNlciwgZXJyb3I6IHVzZXJDaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJ3VzZXJuYW1lJylcbiAgICAgIC5lcSgndXNlcm5hbWUnLCB1c2VybmFtZSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh1c2VyQ2hlY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZXhpc3RpbmcgdXNlcjonLCB1c2VyQ2hlY2tFcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VybmFtZSBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0b2tlbiBleGlzdHMgYW5kIGdldCBleHBpcnkgZGF0ZVxuICAgIGNvbnN0IHsgZGF0YTogdG9rZW5EYXRhLCBlcnJvcjogdG9rZW5FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd0b2tlbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3Rva2VuJywgdG9rZW4pXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAodG9rZW5FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gdmVyaWZpY2F0aW9uIGVycm9yOicsIHRva2VuRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0b2tlbkRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b2tlbicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRva2VuIGlzIGFscmVhZHkgdXNlZFxuICAgIGlmICh0b2tlbkRhdGEuaXNfdXNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBoYXMgYWxyZWFkeSBiZWVuIHVzZWQnKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHVzZXIgd2l0aCBkZXZpY2UgZmluZ2VycHJpbnRcbiAgICBjb25zdCBuZXdVc2VyRGF0YSA9IHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICB0b2tlbixcbiAgICAgIGRldmljZV9maW5nZXJwcmludDogZGV2aWNlRmluZ2VycHJpbnQsXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB0b2tlbl9leHBpcnk6IHRva2VuRGF0YS5leHBpcnlfZGF0ZVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBjcmVhdGUgdXNlciB3aXRoIGRhdGE6JywgeyBcbiAgICAgIC4uLm5ld1VzZXJEYXRhLFxuICAgICAgcGFzc3dvcmQ6ICdbUkVEQUNURURdJyxcbiAgICAgIHRva2VuOiAnW1JFREFDVEVEXSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZGF0YTogbmV3VXNlciwgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5pbnNlcnQoW25ld1VzZXJEYXRhXSlcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGNyZWF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEZXRhaWxlZCBlcnJvciBjcmVhdGluZyB1c2VyOicsIHtcbiAgICAgICAgbWVzc2FnZTogY3JlYXRlRXJyb3IubWVzc2FnZSxcbiAgICAgICAgZGV0YWlsczogY3JlYXRlRXJyb3IuZGV0YWlscyxcbiAgICAgICAgaGludDogY3JlYXRlRXJyb3IuaGludCxcbiAgICAgICAgY29kZTogY3JlYXRlRXJyb3IuY29kZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdXNlciBhY2NvdW50OiAke2NyZWF0ZUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0b2tlbiBhcyB1c2VkXG4gICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndG9rZW5zJylcbiAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgaXNfdXNlZDogdHJ1ZSxcbiAgICAgICAgdXNlZF9ieTogdXNlcm5hbWVcbiAgICAgIH0pXG4gICAgICAuZXEoJ3Rva2VuJywgdG9rZW4pO1xuXG4gICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0b2tlbiBzdGF0dXM6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgLy8gQ29uc2lkZXIgcm9sbGluZyBiYWNrIHVzZXIgY3JlYXRpb24gaGVyZVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgY3JlYXRlZCB1c2VyOicsIHsgXG4gICAgICAuLi5uZXdVc2VyLFxuICAgICAgcGFzc3dvcmQ6ICdbUkVEQUNURURdJyxcbiAgICAgIHRva2VuOiAnW1JFREFDVEVEXSdcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB1c2VyOiBuZXdVc2VyLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTaWduIHVwIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbk91dCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gZ2V0U2Vzc2lvbigpO1xuICAgIGlmIChzZXNzaW9uPy5zZXNzaW9uSWQgJiYgc2Vzc2lvbj8udXNlcklkKSB7XG4gICAgICAvLyBVc2UgYWRtaW4gY2xpZW50IGZvciBzZXNzaW9uIHRlcm1pbmF0aW9uXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzZXNzaW9ucycpXG4gICAgICAgIC51cGRhdGUoeyBpc19hY3RpdmU6IGZhbHNlIH0pXG4gICAgICAgIC5lcSgnc2Vzc2lvbl9pZCcsIHNlc3Npb24uc2Vzc2lvbklkKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCBzZXNzaW9uLnVzZXJJZCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbmRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBzaWduIG91dDonLCBlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYXJTZXNzaW9uKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTZXNzaW9uKHVzZXI6IFVzZXJTZXNzaW9uKSB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Nlc3Npb24nLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNlc3Npb246JywgZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXNzaW9uKCk6IFVzZXJTZXNzaW9uIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZXNzaW9uJyk7XG4gICAgaWYgKCFzZXNzaW9uKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzZXNzaW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIHNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNlc3Npb24oKSB7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzZXNzaW9uJyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1Nlc3Npb24oKSB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXRTZXNzaW9uKCk7XG4gIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5pc0xvZ2dlZEluKSByZXR1cm4gbnVsbDtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGFkbWluIHNlc3Npb25cbiAgaWYgKHNlc3Npb24uaXNBZG1pbikge1xuICAgIGlmIChzZXNzaW9uLnVzZXJuYW1lID09PSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BRE1JTl9VU0VSTkFNRSkge1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgc2Vzc2lvbiBmb3IgdXNlcjonLCBzZXNzaW9uLnVzZXJuYW1lKTtcblxuICAgIC8vIEdldCB1c2VyIGRhdGFcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd1c2VybmFtZScsIHNlc3Npb24udXNlcm5hbWUpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVc2VyIGxvb2t1cCBlcnJvcjonLCB1c2VyRXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgY2xlYXIgc2Vzc2lvbiBpbW1lZGlhdGVseSBvbiBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKHVzZXJFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uOyAvLyBLZWVwIHNlc3Npb24gb24gdGVtcG9yYXJ5IGVycm9yc1xuICAgICAgfVxuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB2ZXJpZnkgdXNlciBhY2Nlc3MnKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZXJEYXRhKSB7XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgZm91bmQgb3IgYWNjZXNzIHJldm9rZWQnKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdG9rZW4gZGF0YVxuICAgIGNvbnN0IHsgZGF0YTogdG9rZW5EYXRhLCBlcnJvcjogdG9rZW5FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd0b2tlbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3Rva2VuJywgdXNlckRhdGEudG9rZW4pXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAodG9rZW5FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gbG9va3VwIGVycm9yOicsIHRva2VuRXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgY2xlYXIgc2Vzc2lvbiBpbW1lZGlhdGVseSBvbiBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKHRva2VuRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICByZXR1cm4gc2Vzc2lvbjsgLy8gS2VlcCBzZXNzaW9uIG9uIHRlbXBvcmFyeSBlcnJvcnNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRva2VuRGF0YSkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4uIFBsZWFzZSBjb250YWN0IGFkbWluLicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRva2VuIGlzIGV4cGlyZWRcbiAgICBjb25zdCBleHBpcnlEYXRlID0gbmV3IERhdGUodG9rZW5EYXRhLmV4cGlyeV9kYXRlKTtcbiAgICBpZiAoZXhwaXJ5RGF0ZSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGFjY2VzcyB0b2tlbiBoYXMgZXhwaXJlZC4gUGxlYXNlIGNvbnRhY3QgYWRtaW4gZm9yIHJlbmV3YWwuJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgc3RpbGwgYWN0aXZlXG4gICAgaWYgKCF0b2tlbkRhdGEuaXNfdXNlZCkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgdG9rZW4gaGFzIGJlZW4gZGVhY3RpdmF0ZWQuIFBsZWFzZSBjb250YWN0IGFkbWluIHRvIHJlYWN0aXZhdGUuJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgc2Vzc2lvbiBpZiB3ZSBoYXZlIHRoZSByZXF1aXJlZCBkYXRhXG4gICAgaWYgKHNlc3Npb24uc2Vzc2lvbklkICYmIHNlc3Npb24udXNlcklkKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IGF3YWl0IHZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uLnNlc3Npb25JZCwgc2Vzc2lvbi51c2VySWQpO1xuICAgICAgaWYgKCFpc1ZhbGlkU2Vzc2lvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nlc3Npb24gdmFsaWRhdGlvbiBmYWlsZWQsIGJ1dCBrZWVwaW5nIHNlc3Npb24gYWN0aXZlJyk7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgY2xlYXJpbmcgaW1tZWRpYXRlbHksIHdlJ2xsIGtlZXAgdGhlIHNlc3Npb25cbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBzZXNzaW9uIHdpdGggbGF0ZXN0IGRhdGFcbiAgICBjb25zdCB1cGRhdGVkU2Vzc2lvbiA9IHtcbiAgICAgIC4uLnNlc3Npb24sXG4gICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUsXG4gICAgICB1c2VySWQ6IHVzZXJEYXRhLmlkLFxuICAgICAgaXNMb2dnZWRJbjogdHJ1ZSxcbiAgICAgIGlzQWRtaW46IGZhbHNlLFxuICAgICAgdG9rZW46IHVzZXJEYXRhLnRva2VuLFxuICAgICAgZGV2aWNlRmluZ2VycHJpbnQ6IHNlc3Npb24uZGV2aWNlRmluZ2VycHJpbnRcbiAgICB9O1xuXG4gICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCBzZXNzaW9uXG4gICAgc2F2ZVNlc3Npb24odXBkYXRlZFNlc3Npb24pO1xuXG4gICAgcmV0dXJuIHVwZGF0ZWRTZXNzaW9uO1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGNoZWNrIGVycm9yOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBPbmx5IGNsZWFyIHNlc3Npb24gZm9yIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIGVycm9yc1xuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdyZXZva2VkJykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2V4cGlyZWQnKSB8fCBcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZGVhY3RpdmF0ZWQnKSkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgfVxuICAgIFxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRva2VuKGR1cmF0aW9uOiBzdHJpbmcgPSAnMWgnKTogc3RyaW5nIHtcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgdG9rZW4gdXNpbmcgVVVJRFxuICByZXR1cm4gdXVpZHY0KCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlBZG1pbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgYWRtaW5TZXNzaW9uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2Vzc2lvbicpO1xuICBpZiAoIWFkbWluU2Vzc2lvbikgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IEpTT04ucGFyc2UoYWRtaW5TZXNzaW9uKTtcbiAgICByZXR1cm4gc2Vzc2lvbi51c2VybmFtZSA9PT0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fVVNFUk5BTUUgJiYgc2Vzc2lvbi5pc0xvZ2dlZEluID09PSB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBhZG1pbiBzZXNzaW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJ2NCIsInV1aWR2NCIsImdldERldmljZUZpbmdlcnByaW50Iiwic2VydmljZVJvbGVLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsInN1cGFiYXNlIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJhZG1pblN1cGFiYXNlIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJ1c2VySWQiLCJkZXZpY2VGaW5nZXJwcmludCIsImNvbnNvbGUiLCJsb2ciLCJzZXNzaW9uSWQiLCJlcnJvciIsImRlYWN0aXZhdGVFcnJvciIsImZyb20iLCJ1cGRhdGUiLCJpc19hY3RpdmUiLCJlcSIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInNlc3Npb25faWQiLCJkZXZpY2VfZmluZ2VycHJpbnQiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibGFzdF9hY3RpdmUiLCJFcnJvciIsImNoZWNrQWN0aXZlU2Vzc2lvbiIsImRhdGEiLCJzZXNzaW9ucyIsInNlbGVjdCIsInNpbmdsZSIsInZhbGlkYXRlU2Vzc2lvbiIsInNlc3Npb24iLCJ1cGRhdGVFcnJvciIsImVuZFNlc3Npb24iLCJzaWduSW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiTkVYVF9QVUJMSUNfQURNSU5fVVNFUk5BTUUiLCJORVhUX1BVQkxJQ19BRE1JTl9QQVNTV09SRCIsImFkbWluU2Vzc2lvbiIsImlzTG9nZ2VkSW4iLCJpc0FkbWluIiwic2F2ZVNlc3Npb24iLCJ1c2VyRGF0YSIsInVzZXJFcnJvciIsImV4aXN0aW5nU2Vzc2lvbnMiLCJzZXNzaW9uRXJyb3IiLCJpZCIsImxlbmd0aCIsImN1cnJlbnRTZXNzaW9uIiwidXNlclNlc3Npb24iLCJ0b2tlbiIsInRva2VuRXhwaXJ5IiwidG9rZW5fZXhwaXJ5Iiwic2lnblVwIiwiZXhpc3RpbmdVc2VyIiwidXNlckNoZWNrRXJyb3IiLCJ0b2tlbkRhdGEiLCJ0b2tlbkVycm9yIiwiaXNfdXNlZCIsIm5ld1VzZXJEYXRhIiwiZXhwaXJ5X2RhdGUiLCJuZXdVc2VyIiwibWVzc2FnZSIsImRldGFpbHMiLCJoaW50IiwiY29kZSIsInVzZWRfYnkiLCJ1c2VyIiwic2lnbk91dCIsImdldFNlc3Npb24iLCJjbGVhclNlc3Npb24iLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEl0ZW0iLCJwYXJzZSIsInJlbW92ZUl0ZW0iLCJjaGVja1Nlc3Npb24iLCJleHBpcnlEYXRlIiwiaXNWYWxpZFNlc3Npb24iLCJ3YXJuIiwidXBkYXRlZFNlc3Npb24iLCJpbmNsdWRlcyIsImdlbmVyYXRlVG9rZW4iLCJkdXJhdGlvbiIsInZlcmlmeUFkbWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/auth.ts\n"));

/***/ })

});