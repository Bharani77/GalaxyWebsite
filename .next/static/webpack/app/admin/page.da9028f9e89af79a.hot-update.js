"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/utils/auth.ts":
/*!***************************!*\
  !*** ./src/utils/auth.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adminSupabase: function() { return /* binding */ adminSupabase; },\n/* harmony export */   checkSession: function() { return /* binding */ checkSession; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   endSession: function() { return /* binding */ endSession; },\n/* harmony export */   generateToken: function() { return /* binding */ generateToken; },\n/* harmony export */   getSession: function() { return /* binding */ getSession; },\n/* harmony export */   saveSession: function() { return /* binding */ saveSession; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   validateSession: function() { return /* binding */ validateSession; },\n/* harmony export */   verifyAdmin: function() { return /* binding */ verifyAdmin; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _fingerprint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fingerprint */ \"(app-pages-browser)/./src/utils/fingerprint.ts\");\n\n\n\n// Create a Supabase client with the service role key for admin operations\nconst serviceRoleKey = \"your_service_role_key_here\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjeHh2bmljemx5enl1bXVpb2hjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzIzNTAzMDMsImV4cCI6MjA0NzkyNjMwM30.AM5S6xAISMEH41V7pLsJSznd-b2hiene5ZGOClgZh-4\");\n// Create a separate client with service role for session management\nconst adminSupabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://scxxvniczlyzyumuiohc.supabase.co\", serviceRoleKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n});\n// Function to create a new session\nasync function createSession(userId, deviceFingerprint) {\n    const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n    const { error } = await supabase.from(\"sessions\").insert([\n        {\n            session_id: sessionId,\n            user_id: userId,\n            device_fingerprint: deviceFingerprint,\n            is_active: true,\n            created_at: new Date().toISOString()\n        }\n    ]);\n    if (error) {\n        console.error(\"Error creating session:\", error);\n        throw new Error(\"Failed to create session\");\n    }\n    return sessionId;\n}\n// Function to check if user has an active session\nasync function checkActiveSession(userId) {\n    const { data: sessions, error } = await supabase.from(\"sessions\").select(\"*\").eq(\"user_id\", userId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"Error checking active session:\", error);\n        return false;\n    }\n    return !!sessions;\n}\n// Function to validate session\nasync function validateSession(sessionId, userId) {\n    try {\n        console.log(\"Validating session:\", {\n            sessionId,\n            userId\n        });\n        // Use admin client for session validation\n        const { data: session, error } = await adminSupabase.from(\"sessions\").select(\"*\").eq(\"session_id\", sessionId).eq(\"user_id\", userId).eq(\"is_active\", true).single();\n        if (error) {\n            console.error(\"Session validation error:\", error);\n            return false;\n        }\n        if (!session) {\n            console.log(\"No active session found\");\n            return false;\n        }\n        console.log(\"Found active session:\", session);\n        // Update last_active timestamp using admin client\n        const { error: updateError } = await adminSupabase.from(\"sessions\").update({\n            last_active: new Date().toISOString()\n        }).eq(\"session_id\", sessionId).eq(\"user_id\", userId);\n        if (updateError) {\n            console.error(\"Error updating last_active:\", updateError);\n        // Don't fail validation just because we couldn't update timestamp\n        }\n        return true;\n    } catch (error) {\n        console.error(\"Unexpected error in validateSession:\", error);\n        return false;\n    }\n}\n// Function to end session\nasync function endSession(sessionId) {\n    await adminSupabase.from(\"sessions\").update({\n        is_active: false\n    }).eq(\"session_id\", sessionId);\n}\nasync function signIn(username, password) {\n    try {\n        console.log(\"Starting sign in process for username:\", username);\n        // Get current device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Device fingerprint:\", deviceFingerprint);\n        // Check if this is an admin login attempt\n        if (username === \"Bharani\") {\n            if (password === \"HackerBharani\") {\n                const sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n                const adminSession = {\n                    username: username,\n                    isLoggedIn: true,\n                    isAdmin: true,\n                    deviceFingerprint,\n                    sessionId,\n                    userId: \"admin\" // Special case for admin\n                };\n                saveSession(adminSession);\n                return adminSession;\n            }\n            throw new Error(\"Invalid username or password\");\n        }\n        // Normal user authentication\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", username).single();\n        if (userError || !userData) {\n            console.error(\"User lookup error:\", userError);\n            throw new Error(\"Invalid username or password\");\n        }\n        // Create new session\n        let sessionId;\n        try {\n            sessionId = await createSession(userData.id, deviceFingerprint);\n            console.log(\"Created new session:\", sessionId);\n        } catch (error) {\n            console.error(\"Failed to create session:\", error);\n            throw new Error(\"Failed to create session. Please try again.\");\n        }\n        const userSession = {\n            username: userData.username,\n            userId: userData.id,\n            isLoggedIn: true,\n            sessionId,\n            token: userData.token,\n            deviceFingerprint,\n            isAdmin: false\n        };\n        console.log(\"Saving user session:\", {\n            ...userSession,\n            token: \"[REDACTED]\"\n        });\n        saveSession(userSession);\n        return userSession;\n    } catch (error) {\n        console.error(\"Sign in error:\", error);\n        throw error;\n    }\n}\nasync function signUp(username, password, token) {\n    try {\n        console.log(\"Starting sign up process for username:\", username);\n        // Get device fingerprint\n        const deviceFingerprint = await (0,_fingerprint__WEBPACK_IMPORTED_MODULE_0__.getDeviceFingerprint)();\n        console.log(\"Generated device fingerprint:\", deviceFingerprint);\n        // Check if username already exists\n        const { data: existingUser, error: userCheckError } = await supabase.from(\"users\").select(\"username\").eq(\"username\", username).single();\n        if (userCheckError) {\n            console.error(\"Error checking existing user:\", userCheckError);\n        }\n        if (existingUser) {\n            throw new Error(\"Username already exists\");\n        }\n        // Verify token exists and get expiry date\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", token).single();\n        if (tokenError) {\n            console.error(\"Token verification error:\", tokenError);\n            throw new Error(\"Invalid token\");\n        }\n        if (!tokenData) {\n            throw new Error(\"Invalid token\");\n        }\n        // Check if token is already used\n        if (tokenData.is_used) {\n            throw new Error(\"Token has already been used\");\n        }\n        // Create new user with device fingerprint\n        const newUserData = {\n            username,\n            password,\n            token,\n            device_fingerprint: deviceFingerprint,\n            created_at: new Date().toISOString(),\n            token_expiry: tokenData.expiry_date\n        };\n        console.log(\"Attempting to create user with data:\", {\n            ...newUserData,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        const { data: newUser, error: createError } = await supabase.from(\"users\").insert([\n            newUserData\n        ]).select().single();\n        if (createError) {\n            console.error(\"Detailed error creating user:\", {\n                message: createError.message,\n                details: createError.details,\n                hint: createError.hint,\n                code: createError.code\n            });\n            throw new Error(\"Failed to create user account: \".concat(createError.message));\n        }\n        // Mark token as used\n        const { error: updateError } = await supabase.from(\"tokens\").update({\n            is_used: true,\n            used_by: username\n        }).eq(\"token\", token);\n        if (updateError) {\n            console.error(\"Error updating token status:\", updateError);\n        // Consider rolling back user creation here\n        }\n        console.log(\"Successfully created user:\", {\n            ...newUser,\n            password: \"[REDACTED]\",\n            token: \"[REDACTED]\"\n        });\n        return {\n            user: newUser,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Sign up error:\", error);\n        throw error;\n    }\n}\nasync function signOut() {\n    try {\n        const session = getSession();\n        if ((session === null || session === void 0 ? void 0 : session.sessionId) && (session === null || session === void 0 ? void 0 : session.userId)) {\n            // Use admin client for session termination\n            const { error } = await adminSupabase.from(\"sessions\").update({\n                is_active: false\n            }).eq(\"session_id\", session.sessionId).eq(\"user_id\", session.userId);\n            if (error) {\n                console.error(\"Error ending session:\", error);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during sign out:\", error);\n    } finally{\n        clearSession();\n    }\n}\nfunction saveSession(user) {\n    try {\n        localStorage.setItem(\"userSession\", JSON.stringify(user));\n        console.log(\"Session saved successfully:\", user);\n    } catch (error) {\n        console.error(\"Error saving session:\", error);\n    }\n}\nfunction getSession() {\n    try {\n        const session = localStorage.getItem(\"userSession\");\n        if (!session) return null;\n        return JSON.parse(session);\n    } catch (error) {\n        console.error(\"Error reading session:\", error);\n        return null;\n    }\n}\nfunction clearSession() {\n    localStorage.removeItem(\"userSession\");\n}\nasync function checkSession() {\n    const session = getSession();\n    if (!session || !session.isLoggedIn) return null;\n    // Check if this is an admin session\n    if (session.isAdmin) {\n        if (session.username === \"Bharani\") {\n            return session;\n        }\n        clearSession();\n        return null;\n    }\n    try {\n        // Get user data\n        const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"username\", session.username).single();\n        if (userError || !userData) {\n            clearSession();\n            throw new Error(\"User not found or access revoked\");\n        }\n        // Get token data\n        const { data: tokenData, error: tokenError } = await supabase.from(\"tokens\").select(\"*\").eq(\"token\", userData.token).single();\n        if (tokenError || !tokenData) {\n            clearSession();\n            throw new Error(\"Invalid token. Please contact admin.\");\n        }\n        // Check if token is expired\n        const expiryDate = new Date(tokenData.expiry_date);\n        if (expiryDate < new Date()) {\n            clearSession();\n            throw new Error(\"Your access token has expired. Please contact admin for renewal.\");\n        }\n        // Check if token is still active\n        if (!tokenData.is_used) {\n            clearSession();\n            throw new Error(\"Your token has been deactivated. Please contact admin to reactivate.\");\n        }\n        // Validate session\n        if (!session.sessionId || !session.userId) {\n            clearSession();\n            throw new Error(\"Invalid session data. Please sign in again.\");\n        }\n        const isValidSession = await validateSession(session.sessionId, session.userId);\n        if (!isValidSession) {\n            clearSession();\n            throw new Error(\"Invalid session. Please sign in again.\");\n        }\n        // Return the complete session data\n        return {\n            username: session.username,\n            userId: session.userId,\n            isLoggedIn: true,\n            isAdmin: false,\n            token: userData.token,\n            sessionId: session.sessionId,\n            deviceFingerprint: session.deviceFingerprint\n        };\n    } catch (error) {\n        // Clear session for any authentication-related errors\n        if (error.message.includes(\"token\") || error.message.includes(\"access\") || error.message.includes(\"session\")) {\n            clearSession();\n        }\n        throw error;\n    }\n}\nfunction generateToken() {\n    let duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"1h\";\n    // Generate a unique token using UUID\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n}\nasync function verifyAdmin() {\n    const adminSession = localStorage.getItem(\"adminSession\");\n    if (!adminSession) return false;\n    try {\n        const session = JSON.parse(adminSession);\n        return session.username === \"Bharani\" && session.isLoggedIn === true;\n    } catch (error) {\n        console.error(\"Error verifying admin session:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEMsU0FBc0MsSUFBSWtDLFFBQVFXLFVBQVUsS0FBSztJQUMvRixFQUFFLE9BQU8vQixPQUFPO1FBQ2RVLFFBQVFWLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9hdXRoLnRzP2ZkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgZ2V0RGV2aWNlRmluZ2VycHJpbnQgfSBmcm9tICcuL2ZpbmdlcnByaW50JztcblxuLy8gQ3JlYXRlIGEgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHNlcnZpY2Ugcm9sZSBrZXkgZm9yIGFkbWluIG9wZXJhdGlvbnNcbmNvbnN0IHNlcnZpY2VSb2xlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhXG4pO1xuXG4vLyBDcmVhdGUgYSBzZXBhcmF0ZSBjbGllbnQgd2l0aCBzZXJ2aWNlIHJvbGUgZm9yIHNlc3Npb24gbWFuYWdlbWVudFxuZXhwb3J0IGNvbnN0IGFkbWluU3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXG4gIHNlcnZpY2VSb2xlS2V5ISxcbiAge1xuICAgIGF1dGg6IHtcbiAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXG4gICAgfVxuICB9XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJTZXNzaW9uIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgaXNMb2dnZWRJbjogYm9vbGVhbjtcbiAgdG9rZW5FeHBpcnk/OiBzdHJpbmc7XG4gIHRva2VuPzogc3RyaW5nIHwgbnVsbDtcbiAgaXNBZG1pbj86IGJvb2xlYW47XG4gIGRldmljZUZpbmdlcnByaW50Pzogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG4gIHNlc3Npb25JZD86IHN0cmluZztcbn1cblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IHNlc3Npb25cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlc3Npb24odXNlcklkOiBzdHJpbmcsIGRldmljZUZpbmdlcnByaW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzZXNzaW9uSWQgPSB1dWlkdjQoKTtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgIC5pbnNlcnQoW1xuICAgICAge1xuICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgZGV2aWNlX2ZpbmdlcnByaW50OiBkZXZpY2VGaW5nZXJwcmludCxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICBdKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc2Vzc2lvbicpO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb25JZDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgdXNlciBoYXMgYW4gYWN0aXZlIHNlc3Npb25cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aXZlU2Vzc2lvbih1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB7IGRhdGE6IHNlc3Npb25zLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnc2Vzc2lvbnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGFjdGl2ZSBzZXNzaW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFzZXNzaW9ucztcbn1cblxuLy8gRnVuY3Rpb24gdG8gdmFsaWRhdGUgc2Vzc2lvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVmFsaWRhdGluZyBzZXNzaW9uOicsIHsgc2Vzc2lvbklkLCB1c2VySWQgfSk7XG4gICAgXG4gICAgLy8gVXNlIGFkbWluIGNsaWVudCBmb3Igc2Vzc2lvbiB2YWxpZGF0aW9uXG4gICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdzZXNzaW9uX2lkJywgc2Vzc2lvbklkKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIHZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgY29uc29sZS5sb2coJ05vIGFjdGl2ZSBzZXNzaW9uIGZvdW5kJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0ZvdW5kIGFjdGl2ZSBzZXNzaW9uOicsIHNlc3Npb24pO1xuXG4gICAgLy8gVXBkYXRlIGxhc3RfYWN0aXZlIHRpbWVzdGFtcCB1c2luZyBhZG1pbiBjbGllbnRcbiAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgIC51cGRhdGUoeyBsYXN0X2FjdGl2ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG4gICAgICAuZXEoJ3Nlc3Npb25faWQnLCBzZXNzaW9uSWQpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpO1xuXG4gICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBsYXN0X2FjdGl2ZTonLCB1cGRhdGVFcnJvcik7XG4gICAgICAvLyBEb24ndCBmYWlsIHZhbGlkYXRpb24ganVzdCBiZWNhdXNlIHdlIGNvdWxkbid0IHVwZGF0ZSB0aW1lc3RhbXBcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIHZhbGlkYXRlU2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGVuZCBzZXNzaW9uXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5kU2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAudXBkYXRlKHsgaXNfYWN0aXZlOiBmYWxzZSB9KVxuICAgIC5lcSgnc2Vzc2lvbl9pZCcsIHNlc3Npb25JZCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW4odXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8VXNlclNlc3Npb24+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgc2lnbiBpbiBwcm9jZXNzIGZvciB1c2VybmFtZTonLCB1c2VybmFtZSk7XG5cbiAgICAvLyBHZXQgY3VycmVudCBkZXZpY2UgZmluZ2VycHJpbnRcbiAgICBjb25zdCBkZXZpY2VGaW5nZXJwcmludCA9IGF3YWl0IGdldERldmljZUZpbmdlcnByaW50KCk7XG4gICAgY29uc29sZS5sb2coJ0RldmljZSBmaW5nZXJwcmludDonLCBkZXZpY2VGaW5nZXJwcmludCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGFkbWluIGxvZ2luIGF0dGVtcHRcbiAgICBpZiAodXNlcm5hbWUgPT09IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX1VTRVJOQU1FKSB7XG4gICAgICBpZiAocGFzc3dvcmQgPT09IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX1BBU1NXT1JEKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHV1aWR2NCgpO1xuICAgICAgICBjb25zdCBhZG1pblNlc3Npb246IFVzZXJTZXNzaW9uID0ge1xuICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcbiAgICAgICAgICBpc0xvZ2dlZEluOiB0cnVlLFxuICAgICAgICAgIGlzQWRtaW46IHRydWUsXG4gICAgICAgICAgZGV2aWNlRmluZ2VycHJpbnQsXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIHVzZXJJZDogJ2FkbWluJyAvLyBTcGVjaWFsIGNhc2UgZm9yIGFkbWluXG4gICAgICAgIH07XG4gICAgICAgIHNhdmVTZXNzaW9uKGFkbWluU2Vzc2lvbik7XG4gICAgICAgIHJldHVybiBhZG1pblNlc3Npb247XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUgb3IgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWwgdXNlciBhdXRoZW50aWNhdGlvblxuICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJuYW1lJywgdXNlcm5hbWUpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAodXNlckVycm9yIHx8ICF1c2VyRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcignVXNlciBsb29rdXAgZXJyb3I6JywgdXNlckVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgc2Vzc2lvblxuICAgIGxldCBzZXNzaW9uSWQ6IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgc2Vzc2lvbklkID0gYXdhaXQgY3JlYXRlU2Vzc2lvbih1c2VyRGF0YS5pZCwgZGV2aWNlRmluZ2VycHJpbnQpO1xuICAgICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgbmV3IHNlc3Npb246Jywgc2Vzc2lvbklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJTZXNzaW9uOiBVc2VyU2Vzc2lvbiA9IHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcbiAgICAgIHVzZXJJZDogdXNlckRhdGEuaWQsXG4gICAgICBpc0xvZ2dlZEluOiB0cnVlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdG9rZW46IHVzZXJEYXRhLnRva2VuLFxuICAgICAgZGV2aWNlRmluZ2VycHJpbnQsXG4gICAgICBpc0FkbWluOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnU2F2aW5nIHVzZXIgc2Vzc2lvbjonLCB7IC4uLnVzZXJTZXNzaW9uLCB0b2tlbjogJ1tSRURBQ1RFRF0nIH0pO1xuICAgIHNhdmVTZXNzaW9uKHVzZXJTZXNzaW9uKTtcbiAgICByZXR1cm4gdXNlclNlc3Npb247XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ24gaW4gZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduVXAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgdG9rZW46IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNpZ24gdXAgcHJvY2VzcyBmb3IgdXNlcm5hbWU6JywgdXNlcm5hbWUpO1xuXG4gICAgLy8gR2V0IGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IGRldmljZUZpbmdlcnByaW50ID0gYXdhaXQgZ2V0RGV2aWNlRmluZ2VycHJpbnQoKTtcbiAgICBjb25zb2xlLmxvZygnR2VuZXJhdGVkIGRldmljZSBmaW5nZXJwcmludDonLCBkZXZpY2VGaW5nZXJwcmludCk7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VybmFtZSBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VyLCBlcnJvcjogdXNlckNoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgndXNlcm5hbWUnKVxuICAgICAgLmVxKCd1c2VybmFtZScsIHVzZXJuYW1lKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHVzZXJDaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBleGlzdGluZyB1c2VyOicsIHVzZXJDaGVja0Vycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RpbmdVc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXJuYW1lIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRva2VuIGV4aXN0cyBhbmQgZ2V0IGV4cGlyeSBkYXRlXG4gICAgY29uc3QgeyBkYXRhOiB0b2tlbkRhdGEsIGVycm9yOiB0b2tlbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Rva2VucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9rZW4nLCB0b2tlbilcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh0b2tlbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiB2ZXJpZmljYXRpb24gZXJyb3I6JywgdG9rZW5FcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRva2VuRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgYWxyZWFkeSB1c2VkXG4gICAgaWYgKHRva2VuRGF0YS5pc191c2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCcpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgdXNlciB3aXRoIGRldmljZSBmaW5nZXJwcmludFxuICAgIGNvbnN0IG5ld1VzZXJEYXRhID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHRva2VuLFxuICAgICAgZGV2aWNlX2ZpbmdlcnByaW50OiBkZXZpY2VGaW5nZXJwcmludCxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHRva2VuX2V4cGlyeTogdG9rZW5EYXRhLmV4cGlyeV9kYXRlXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSB1c2VyIHdpdGggZGF0YTonLCB7IFxuICAgICAgLi4ubmV3VXNlckRhdGEsXG4gICAgICBwYXNzd29yZDogJ1tSRURBQ1RFRF0nLFxuICAgICAgdG9rZW46ICdbUkVEQUNURURdJ1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBkYXRhOiBuZXdVc2VyLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLmluc2VydChbbmV3VXNlckRhdGFdKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RldGFpbGVkIGVycm9yIGNyZWF0aW5nIHVzZXI6Jywge1xuICAgICAgICBtZXNzYWdlOiBjcmVhdGVFcnJvci5tZXNzYWdlLFxuICAgICAgICBkZXRhaWxzOiBjcmVhdGVFcnJvci5kZXRhaWxzLFxuICAgICAgICBoaW50OiBjcmVhdGVFcnJvci5oaW50LFxuICAgICAgICBjb2RlOiBjcmVhdGVFcnJvci5jb2RlXG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB1c2VyIGFjY291bnQ6ICR7Y3JlYXRlRXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRva2VuIGFzIHVzZWRcbiAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd0b2tlbnMnKVxuICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICBpc191c2VkOiB0cnVlLFxuICAgICAgICB1c2VkX2J5OiB1c2VybmFtZVxuICAgICAgfSlcbiAgICAgIC5lcSgndG9rZW4nLCB0b2tlbik7XG5cbiAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRva2VuIHN0YXR1czonLCB1cGRhdGVFcnJvcik7XG4gICAgICAvLyBDb25zaWRlciByb2xsaW5nIGJhY2sgdXNlciBjcmVhdGlvbiBoZXJlXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIHVzZXI6JywgeyBcbiAgICAgIC4uLm5ld1VzZXIsXG4gICAgICBwYXNzd29yZDogJ1tSRURBQ1RFRF0nLFxuICAgICAgdG9rZW46ICdbUkVEQUNURURdJ1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IG5ld1VzZXIsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ24gdXAgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KCkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBnZXRTZXNzaW9uKCk7XG4gICAgaWYgKHNlc3Npb24/LnNlc3Npb25JZCAmJiBzZXNzaW9uPy51c2VySWQpIHtcbiAgICAgIC8vIFVzZSBhZG1pbiBjbGllbnQgZm9yIHNlc3Npb24gdGVybWluYXRpb25cbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Nlc3Npb25zJylcbiAgICAgICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAgICAgLmVxKCdzZXNzaW9uX2lkJywgc2Vzc2lvbi5zZXNzaW9uSWQpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHNlc3Npb24udXNlcklkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVuZGluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHNpZ24gb3V0OicsIGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhclNlc3Npb24oKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVNlc3Npb24odXNlcjogVXNlclNlc3Npb24pIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlclNlc3Npb24nLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG4gICAgY29uc29sZS5sb2coJ1Nlc3Npb24gc2F2ZWQgc3VjY2Vzc2Z1bGx5OicsIHVzZXIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Vzc2lvbigpOiBVc2VyU2Vzc2lvbiB8IG51bGwge1xuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlclNlc3Npb24nKTtcbiAgICBpZiAoIXNlc3Npb24pIHJldHVybiBudWxsO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHNlc3Npb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU2Vzc2lvbigpIHtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJTZXNzaW9uJyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1Nlc3Npb24oKSB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXRTZXNzaW9uKCk7XG4gIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5pc0xvZ2dlZEluKSByZXR1cm4gbnVsbDtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGFkbWluIHNlc3Npb25cbiAgaWYgKHNlc3Npb24uaXNBZG1pbikge1xuICAgIGlmIChzZXNzaW9uLnVzZXJuYW1lID09PSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BRE1JTl9VU0VSTkFNRSkge1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgdXNlciBkYXRhXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcm5hbWUnLCBzZXNzaW9uLnVzZXJuYW1lKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlckRhdGEpIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCBvciBhY2Nlc3MgcmV2b2tlZCcpO1xuICAgIH1cblxuICAgIC8vIEdldCB0b2tlbiBkYXRhXG4gICAgY29uc3QgeyBkYXRhOiB0b2tlbkRhdGEsIGVycm9yOiB0b2tlbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Rva2VucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9rZW4nLCB1c2VyRGF0YS50b2tlbilcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICh0b2tlbkVycm9yIHx8ICF0b2tlbkRhdGEpIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuLiBQbGVhc2UgY29udGFjdCBhZG1pbi4nKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBleHBpcmVkXG4gICAgY29uc3QgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKHRva2VuRGF0YS5leHBpcnlfZGF0ZSk7XG4gICAgaWYgKGV4cGlyeURhdGUgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICBjbGVhclNlc3Npb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBhY2Nlc3MgdG9rZW4gaGFzIGV4cGlyZWQuIFBsZWFzZSBjb250YWN0IGFkbWluIGZvciByZW5ld2FsLicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRva2VuIGlzIHN0aWxsIGFjdGl2ZVxuICAgIGlmICghdG9rZW5EYXRhLmlzX3VzZWQpIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIHRva2VuIGhhcyBiZWVuIGRlYWN0aXZhdGVkLiBQbGVhc2UgY29udGFjdCBhZG1pbiB0byByZWFjdGl2YXRlLicpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHNlc3Npb25cbiAgICBpZiAoIXNlc3Npb24uc2Vzc2lvbklkIHx8ICFzZXNzaW9uLnVzZXJJZCkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2Vzc2lvbiBkYXRhLiBQbGVhc2Ugc2lnbiBpbiBhZ2Fpbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IGF3YWl0IHZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uLnNlc3Npb25JZCwgc2Vzc2lvbi51c2VySWQpO1xuICAgIGlmICghaXNWYWxpZFNlc3Npb24pIHtcbiAgICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlc3Npb24uIFBsZWFzZSBzaWduIGluIGFnYWluLicpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgY29tcGxldGUgc2Vzc2lvbiBkYXRhXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lOiBzZXNzaW9uLnVzZXJuYW1lLFxuICAgICAgdXNlcklkOiBzZXNzaW9uLnVzZXJJZCxcbiAgICAgIGlzTG9nZ2VkSW46IHRydWUsXG4gICAgICBpc0FkbWluOiBmYWxzZSxcbiAgICAgIHRva2VuOiB1c2VyRGF0YS50b2tlbixcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbi5zZXNzaW9uSWQsXG4gICAgICBkZXZpY2VGaW5nZXJwcmludDogc2Vzc2lvbi5kZXZpY2VGaW5nZXJwcmludFxuICAgIH07XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIENsZWFyIHNlc3Npb24gZm9yIGFueSBhdXRoZW50aWNhdGlvbi1yZWxhdGVkIGVycm9yc1xuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0b2tlbicpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2FjY2VzcycpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3Nlc3Npb24nKSkge1xuICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRva2VuKGR1cmF0aW9uOiBzdHJpbmcgPSAnMWgnKTogc3RyaW5nIHtcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgdG9rZW4gdXNpbmcgVVVJRFxuICByZXR1cm4gdXVpZHY0KCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlBZG1pbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgYWRtaW5TZXNzaW9uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2Vzc2lvbicpO1xuICBpZiAoIWFkbWluU2Vzc2lvbikgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IEpTT04ucGFyc2UoYWRtaW5TZXNzaW9uKTtcbiAgICByZXR1cm4gc2Vzc2lvbi51c2VybmFtZSA9PT0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fVVNFUk5BTUUgJiYgc2Vzc2lvbi5pc0xvZ2dlZEluID09PSB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBhZG1pbiBzZXNzaW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJ2NCIsInV1aWR2NCIsImdldERldmljZUZpbmdlcnByaW50Iiwic2VydmljZVJvbGVLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsInN1cGFiYXNlIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJhZG1pblN1cGFiYXNlIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJ1c2VySWQiLCJkZXZpY2VGaW5nZXJwcmludCIsInNlc3Npb25JZCIsImVycm9yIiwiZnJvbSIsImluc2VydCIsInNlc3Npb25faWQiLCJ1c2VyX2lkIiwiZGV2aWNlX2ZpbmdlcnByaW50IiwiaXNfYWN0aXZlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJFcnJvciIsImNoZWNrQWN0aXZlU2Vzc2lvbiIsImRhdGEiLCJzZXNzaW9ucyIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwidmFsaWRhdGVTZXNzaW9uIiwibG9nIiwic2Vzc2lvbiIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwibGFzdF9hY3RpdmUiLCJlbmRTZXNzaW9uIiwic2lnbkluIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIk5FWFRfUFVCTElDX0FETUlOX1VTRVJOQU1FIiwiTkVYVF9QVUJMSUNfQURNSU5fUEFTU1dPUkQiLCJhZG1pblNlc3Npb24iLCJpc0xvZ2dlZEluIiwiaXNBZG1pbiIsInNhdmVTZXNzaW9uIiwidXNlckRhdGEiLCJ1c2VyRXJyb3IiLCJpZCIsInVzZXJTZXNzaW9uIiwidG9rZW4iLCJzaWduVXAiLCJleGlzdGluZ1VzZXIiLCJ1c2VyQ2hlY2tFcnJvciIsInRva2VuRGF0YSIsInRva2VuRXJyb3IiLCJpc191c2VkIiwibmV3VXNlckRhdGEiLCJ0b2tlbl9leHBpcnkiLCJleHBpcnlfZGF0ZSIsIm5ld1VzZXIiLCJjcmVhdGVFcnJvciIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiaGludCIsImNvZGUiLCJ1c2VkX2J5IiwidXNlciIsInNpZ25PdXQiLCJnZXRTZXNzaW9uIiwiY2xlYXJTZXNzaW9uIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJdGVtIiwicGFyc2UiLCJyZW1vdmVJdGVtIiwiY2hlY2tTZXNzaW9uIiwiZXhwaXJ5RGF0ZSIsImlzVmFsaWRTZXNzaW9uIiwiaW5jbHVkZXMiLCJnZW5lcmF0ZVRva2VuIiwiZHVyYXRpb24iLCJ2ZXJpZnlBZG1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/auth.ts\n"));

/***/ })

});